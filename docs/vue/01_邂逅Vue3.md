##### Vue3的支持

更好的性能,更小的包体积,更好的TypeScript继承,更优秀的API设计

##### Vue就是一个JavaScript库

1. 第一种,在页面中通过CDN的方式来引入
2. 第二种,使用包的方式进行沉淀
3. 第三种,下载Vue的JavaScript,并手动引用
4. 第四种,使用Vue CLi的方式进行创建项目,使用它

##### CDN引入和初体验

app.mount(“#app”)

##### 创建APP

const app = Vue.createApp({})

然后进行挂载操作,app.mount(“#app”)

##### 一点点对前端进行学习使用,慢慢学习操作然后执行

##### 动态展示hello world 数据

##### 在绑定data和methods的时候,他们都只会对在#app里面寻找

****

###### 原生进行实现

首先获取原生Dom元素,然后再进行进行点击事件

然后发生值就修改innerText或者innerHtml或者textContent

Vue采用的是声明式编程  而不是命令式编程

###### 命令式编程

> 这个怎么做 我就去怎么做

1. 获取到Dom
2. 监听点击时间
3. 发生点击
4. 触发事件修改值

###### 声明式编程

> 这个怎么做,机器你去做

1. 声明一个模板
2. 声明data
3. 声明methods
4. 声明click

##### Cookie和Session的区别

Cookie放到客户端,会被伪造,Cookie的体积限制和数量限制,Cookie生命周期累计的

Session放到服务器端,会占用服务器性能,没有体积限制,没有数量限制,可以存放多种数据,Session声明周期是间隙的

##### 为什么要设计成单线程的

防止一个Dom元素会被多个js文件操作,造成安全损失

##### 微任务和宏任务的区别

如果是主任务会被放到js执行栈中立刻完成回调

在Promise的微任务中是是立刻就会被执行的,但是里面调用的resolve和reject的时候 会去调用微任务队列

宏任务队列 比如 setTimeOut setIMMediately,Dom操作,SetInterval,UIRendering,Ajax

微任务队列比如Promise ,nextTick ,queueMicrotask,axios

**执行任何一个宏任务之前(不是队列,一个额宏任务),都会去查看微任务中是否有任务需要执行**

##### throw new Error()

抛出异常后,后续代码不会进行执行

可以抛出一个具体的错误信息

throw(errMessage(),errorCode)

##### 使用try catch进行异常捕获 finally是可以接着执行的