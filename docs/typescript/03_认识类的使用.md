## Ts中类的使用

类与实例之间的关系  实例实现了类,类是实例的创造工厂

**为什么使用export {},因为不export{}就代表着声明在全局属性,会发生变量冲突**

如果给一个私有属性设置值的时候,可以使用getter和setter的方式来进行操作

##### 私有属性,前面的属性使用_来标明这是一个私有属性

如果在ts中不设置为私有属性进行拦截的时候,我们可以通过创建实例.的方式随时可以取到,并修改这个实例上的属性

##### setter和getter的访问器

```ts
set name (){}

get name (){}
```

#### 参数属性 parameter properties

你可以在`构造函数`里面,使用`private和public和protected和readonly`来修饰参数的属性

```ts
type Book = {
  name: string, price: number,
}
class Person1 extends Person {
  name: string;
  age: number;
  constructor(private books: Book[], name: string, age: number) {
    super(name, age);
    this.name = name;
    this.age = age;
  }
  say(): void {
    console.log(this.name)
  }
}
```

#### abstract 抽象类    将共同的部分抽取出来

封装,继承,多态 继承是多态使用的前提,

> 抽象类,让所有的子类继承这个抽象类,抽象类只是确定了所有子类都有的一个方法
>
> 1. 没有具体实现的方法,就是抽象方法
> 2. 抽象方法必须放到抽象类中
> 3. 子类方法必须要实现抽象类中的抽象方法

```ts
abstract class Shape {
  // 只有声明,没有实现体,实现让子类自己实现
  abstract getArea()
}
class Train extends Shape {
  constructor() {
    super()
  }
}
class Name extends Shape {
  constructor() {
    super()
  }
}
class Person2 extends Shape {
  constructor() {
    super()
  }
}
// 继承和多态,子类委托   抽象类是三个的父类
function(shape:Shape){
}
```

### 鸭子类型

如果一只狗,走起来像鸭子,叫起来像鸭子,看起来像鸭子,那么你就可以认为他就是一只鸭子

`只关心属性和行为`,`不关心你是不是具体`的对应的类型

### 类的类型

1.  类可以创建相对应的实例对象
2. 类可以作为这个实例对象的实例
3. 类也可以当中有一个构造签名的函数 

```ts
new () => void
```

#### 对象类型中的修饰符

如果是可选的话,应该使用?,如果是只读的使用readonly

```ts
interface Obj {
  readonly name: string;
  age?: number,
  [index:string]:string
}
```

#### 索引签名

#### 接口继承

1. 减少了相同代码的编写
2. 如果使用第三库,给我们定义了一些属性
3. 你希望自定义接口拥有第三方某一个类型的所有属性,使用继承

#### 接口实现

让一个类,实现一个接口 interface

```ts
class Person implements IKun {
  name:string,
  age:number
}

interface Obj {
  readonly name: string;
  age?: number,
  run: () => number
}

interface Obj2 {
  abc: string
}

class obj implements Obj, Obj2 {
  name: string;
  age: number;
  abc: string;
  run() {
    return 111
  }
}
```

#### 严格字面量检测

对于新鲜的字面量,会进行严格的类型检测,必须完全满足类型的要求(不能有多余的属性)

当使用类型断言或对象字面量的类型扩大,新鲜度会消失

```ts
const obj2 ={
  name:"why",
  age:18,
  height:1.88
}
const obj2 :IPerson =obj2
```

#### 抽象类和接口的区别呢(了解)

1. 抽象类中可以搞一些抽象的东西,子类必须要会实现抽象类
2. 类是对现实社会的一种抽象,抽象类是对抽象的总称,比如是动物
3. 接口是对行为的抽象,  接口可以被多层实现,但抽象类只能被单一继承
4. 抽象类中可以有实现体,但是接口中只能有声明

抽象类是对事物的抽象,表达的是is a的关系,猫是一种动物

接口是对行为的抽象,表达的是has a的关系

#### 枚举属性

> 将一组内可能出现的值,一个个的列举出来,是用enum来进行定义
>
> 枚举属性,有点类似与type字面量属性  type name = "libai" | "book" | "sss”,但是字面量属性不可以赋予值
>
> 会默认给枚举属性,定义一些值,默认赋值的话是0和1
>
> 也可以选择单独给予值

```ts
enum Direction {
  UP = "up",
  DOWN ="down,
  LEFT ="left",
  RIGHT ="right"
}
```

