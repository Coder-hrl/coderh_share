#### 泛型语法的基本使用

> 类型的参数化,让类型像参数一样可以传来传去,目前参数的类型是写死的
>
> 我们可以像传递参数一样传递参数类型

软件工程的主要目的是构建不仅仅明确和一致的API,一般在抽象封装组件时使用

```ts
function Bar<Type>(arg: Type) {
  //同时Type也可以简易化为T类型来设置
  return arg
}

Bar<number>(123)
Bar<string>("213")
```

我们可以完整的传入类型,也可以省略让Ts去推导类型,泛型的参数化  

`泛型`在实际开发中用的是非常非常的多的,`在自定义或者封装组件的时候很常用`,我们可以通过泛型的方式来动态传递组件类型

对于可以一些简单的可以动态来推导出类型,对于很复杂的,则使用<>来强制约束类型

我们可以传入多个类型,我们大部分都使用缩写来表示一个内容注解

```ts
function<T,N>(name:T,age:N){
  return [name,age] 
}
// 使用泛型类型注解
interface IKun<Type>{
  name:Type
  age:number
  slogan:Type
}

const obj =IKun<number>{
}
//将接口使用泛型进行重构,可以让接口参数化,动态决定
```

泛型可以使用类型推导或者使用泛型强制

泛型也是可以继承的



#### 泛型接口和类的使用

#### 泛型约束和类型条件

#### typescript映射类型

#### 条件类型

#### 类型工具和类型体操