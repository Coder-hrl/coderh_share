---
title: 操作系统
---

## 操作系统

1. 帮助用户使用计算机,应用程序的载体,给用户提供接口和服务 `安全高效`
   - 进程是最小的调度单位,需要分配内存才可以进行处理
   - 对应的进程被分配的 cpu 进行处理
   - 还有设备请求管理
2. 用户 ==>应用程序 ==>操作系统 ==>裸机 `操作系统是最接近硬件的层次`
   - 具有命令接口,比如 windows 里面的 cmd,和 mac 中的终端,都是可以与计算机直接进行交互的
   - 或者使用应用程序,应用程序去与操作系统进行交互
   - 比如.bat 文件都被称之为脱机(批处理)命令接口
3. 控制和管理整个计算机系统的软件和硬件资源,合理的组织和调配计算机的各种资源.是计算机系统中最基本的系统软件,给应用提供调度的接口服务.
4. 处理机管理, 存储器管理 , 文件管理, io 设备管理.
5. 用户可以看到的是用户应用空间,操作系统使用的都是内核空间

##### 命令接口

**命令接口** 用户直接使用的接口

- 脱机命令接口 说一堆 做一堆
- 联机命令接口 说一个 做一个

**程序接口** 自己下载程序后调用的接口

- 系统直接被调用的命令接口

**gui 可视化命令接口**

- 图形化操作页面接口,图形化就是可视化操作页面

硬件相当于水泥,木头等原材料,操作系统帮我们把这些硬件扩展为高楼,桌子后被用户更方便使用.

`放入内存,分配cpu上进行使用`,没有安装任何操作系统的计算机称之为裸机

一个裸机内,可以通过安装多个操作系统,比如安装虚拟机等方式,裸机是不可以直接使用的

### 操作系统的特点

##### 并发和并行 ( 重点)

1. 宏观上并发执行,**微观上交替执行**,如果是同一时间内,单个或者多个事件一起执行,被称之为**并行**
2. 多核 cpu 从`机器上表示多并发`,有几个核就代表几个并行量,但是程序的并发量仍不可缺.操作系统的并发一起进行(使得很多软件可以交替`并发`使用)

##### 共享性

> 共享性的前提是并发性,如果失去了并发性,是不可能存在共享性的
>
> **(因为失去并发性,意味着只存在一个软件使用)**

1. **互斥共享** 在一段时间,只能被一个软件使用
2. **同时共享** 在一段时间内,可以交替被软件使用,在宏观上是并发,微观上也可能是交替共享访问的方式 比如交替访问内存
3. **同时共享时,也可以再微观上同时进行** 比如扬声器使用

##### 虚拟

> 比如,内存只有 4GB,但却存在大于 4GB 的软件正在运行
>
> 注意:是先**要分配内存才可以分配 CPU 才可以运行**
>
> 虚拟的前提性也是使用并发.

1. 虚拟存储器,空分复用技术
   - 针对内存存储,
2. 虚拟处理器,时分复用技术

##### 异步性

在一段时间内程序**交替进行**,并不是立刻执行结束的,走走停停,以不可知的方式进去前进.谁有时间谁去用资源.

> 只有在并发性和共享性,才会有异步性和虚拟性的存在,
>
> 操作系统变的内存利用率越来越高,同时让 Cpu 的利用率也越来越高
>
> 提高人机交互效率

`手工操作时间` ==> 独占人工,有人动,没人就不动

`批处理阶段 ` ==> 用磁带进行输入和输出,进行了脱机 内存只有一道程序执行

`多批道处理阶段` ==> 多道程序并发执行,共享计算机资源,**大幅度提高资源提升率**, 没有人机交互能力 **在第一个程序进行计算的时候,第二道程序可以进行输入**

`分时操作系统` ==> 解决了**人机交互**的问题,平分时间, 但是不能根据事情紧急进行优先分配任务 并没有中断机制,每个人只能在同等时间片内使用

`实时操作系统` ==> 在严格的时间内完成所交给的任务,**及时性和可靠性**,能处理紧急事务

    - 并存在硬实时操作系统和软实时操作系统
    - 还存在**网络分布式和个人操作系统**

#### 运行机制和体系结构

> 一般分为 高级程序语言 == > 汇编语言 ==> 机器指令==>机器语言
>
> 操作系统分为可供用户和系统内部管理使用
>
> 特权指令 核心态 内核机制

**代码进行编译翻译后会变成机器可以识别的指令**

操作系统分为两种指令,**特权指令和非特权指令**

- 分为**用户态**和**核心态**
- 内核程序和应用程序
- 最接近计算机硬件的是操作系统的内核,时钟管理,中断控制,和原语(设备控制和 cpu 切换)

内核程序是指**更接近硬件**的程序，运行具有原子性:`中间不可以被中断`

- 内核是底层软件,操作系统最核心，最基本的属性
- 时钟管理 中断处理 原语(设备控制和 cpu 切换)
- 进程管理 程序管理 设备管理

内核是管理层,能够执行核心态, 员工只能执行用户态和应用程序

`大内核`管理层负责大部分的事,效率高,但是组织结构不清晰,结构混乱,难以维护

          - 职能不清晰,导致代发混乱

`微内核`管理层只负责决策,用户负责做很多事,组织机构清晰,但是效率不高,因为人与人之间的工作交接,需要成本

- 多了一层核心态和用户态的不停的切换,效率会变低.
- 职能清晰

#### 中断机制

> 引入了中断机制,实现了并发的实现
>
> 发生中断,**意味着操作系统介入,开展管理工作**.操作系统内核进行**处理中断信号**

实现了多道程序并发执行

因为引入了中断,也就引入了操作系统,开展管理操作

程序 1 执行==>中断==>管理==>程序 2 执行

cpu 进入核心态,发生中断就意味着 cpu 介入操作

**中断是唯一的方式使操作系统由用户态直接到核心态**

**核心态到用户态是执行一个特权指令进行实现的**

本质 信号来源`是否来自cpu内部`,每次指令结束之后,都会来判断是否有外部中断

- 内中断
  - cpu 内部指令 自愿中断 指令切换 和 强制中断 硬件出错,软件中断发生错误
  - 操作系统内部完成的中断,可能系统完成后中断或者程序故障中断
  - 陷入 故障 中止
- 外中断
  - 外部命令,如外设请求,人工干预
  - 是由人工自己来导致的,比如连接鼠标,使用外设打印机
  - CPU**每次执行完一个机器指令之后**,都需要去查看是否有中断指令
  - 中断就意味着需要保存中断之前的数据,以便完成中断任务后执行

#### 系统调用

1. 系统调用和库函数的区别是啥

   库函数内部,封装了系统调用的代码,封装的更加的高级.

   系统调用处于内核态处理,操作系统向上提供**系统调用**的功能

应用软件**通过系统调用请求**操作系统的服务,后由操作系统,**统一来协调进行处理**

应用系统通过系统调用来请求操作系统对资源(如存储分配,io 操作文件管理等)这样可以保证系统的稳定性和安全性

- 设备管理 io 设备 请求释放
- 文件管理 增删改查文件
- 进程管理 进程的建立,撤销,阻塞
- 进程通信 消息传递
- 内存管理 内存回收和分配

陷入指令和**(访管指令)**使用户态在执行结束后,**触发一个内中断**进入一个核心态

**陷入指令**是唯一一个只能在用户态执行,在核心态无法执行的指令

如果影响到了其他进程操作和内存或者 CPU 资源有关的话,都需要系统管理调用

### 进程

> **`程序段`(程序代码) `数据段`(数据信息)和`PCB`(管理进程信息)一起称为进程实体**,PCB 是进程的唯一标志
>
> 当进入多道程序技术之后,就会需要保存和记录进程信息.

1. 进程是动态的过程,具有动态性
2. 进程实体是静态的

进程是资源分配和调度的独立单位;

内存中同时放到多道程序,操作系统通过 PCB 进程控制块,用来描绘进程里面的基本信息

PCB 里面记录了进程的基本信息,后续中断可以通过 PCB 来恢复进程信息

- **进程标识符**(此为唯一的 id 值)和**用户标识符**
- 各种寄存器的值,用来**保存之前中断的信息**
- 进程状态和进程优先级

`链式方式`(分成多个队列的形式)和`索引方式`(建立一个索引表)

- 动态性 进程是程序的执行过程,有产生和消亡的过程
- 并发性 多进程可以同时进行
- 独立性 **进程是可以独立运行的,独立获得调度的单位**
- 异步性 进程会以一种不可预知的方向进行推进
- 结构性 进程中有程序段,数据段和 PCB

#### 运行状态

> 进程是程序的一次执行,由于进程是动态性的,所以存在很多状态
>
> 比如 **就绪态**,运行态,阻塞态(等待态)

`创建态` 初始化 PCB(process control block**进程控制块**),初始化进程所需内存和其他资源

`就绪态 ` 已经有运行的条件,已经分配了内存空间,**只是没有分配 cpu.**

`运行态` 已经开始运行,如果时间片已经结束或者处理机被强占,就会重新回到就绪态

`阻塞态` 因等待一件事暂不能运行 可以重新到**_就绪态_**

`终止态` 因进程遭遇错误,从而需要撤销进程,需要回收进程所需要的资源

#### 进程控制

> 需要对 PCB 的状态标志进行修改,同时需要将其放到相应的队列中

**都是需要队列来进行控制**,比如阻塞队列一,阻塞队列二,就绪队列一等等

**进程控制**就是对`运行状态`的改变

通过原语来实现进程控制,因为**原语在执行后是无法被中断的.**

阻塞原语和唤醒原语,运行在核心态,同时是特权指令

1. 更新 PCB 信息,和状态修改,保存环境
2. 将 PCB 插到合适的队列
3. 分配/回收资源

创建原语,从无到有的过程,创建空的 PCB,初始化,申请资源,插入到就绪队列

进程的阻塞和进程的唤醒是成对出现的.

#### 进程通信 有点类似与 Vue 组件间的通信

进程信息之间的相互交换,因此进程之间的空间内存都是独立存在的

为了保证安全，**一个进程是不可以随便去访问另一个进程的空间的**

所以我们需要进行进程之间的通信,必须是互斥操作(例如 P,V 操作)

- 共享空间(存储) 操作系统创建一个空间用于`数据共享 ` 互斥共享

  - 基于**数据结构共享**，是低效率的
  - 基于**存储区的共享**是较高效率的

- 管道通信 **半双工的通信** 只能进行单方向传输 如果实现双向传输,则需要**双方向管道**

  - 有读数据和写数据的过程 在`一方进行读写的时候 另一方是不能操作`的
  - 没写满`不允许读`, `没读满`不允许写,单方向的操作 **半双工特性**

- 消息传递 以格式化消息的方式进行消息传递

  - 直接通信方式 挂载到**消息缓冲队列** (类似 TCP)

  - 间接通信方式 **信箱**通信方式 (有起止点)

### 线程机制

> 一个进程可以包含多个线程,提供了很强的并发量
>
> 线程就成为了程序执行流的最小单位,可以称之为轻量级的进程.
>
> 引入线程之后,进程就成为了资源分配的最小分配单位
>
> 线程内的并发和切换环境的开销是很低的.

- 在进程的时候,有的时候**也需要并发的执行很多事**,所以引入了线程方法
- `线程是cpu最小的执行单位,同时也是程序执行流最小的单位`
- 线程内的线程运行环境切换的开销非常小,而进程的资源切换是非常大的
- 同一进程中的所有线程是共享同一进程空间
- 线程也有 ID 也有 TCB(thread control block)来记录线程信息
- 可以将进程比喻成`一个个大车间`,而`线程则是里面的小空间和工人

##### 线程模型空间 有点类似与 Vue 的观察者 watcher 模式

> 用户级线程和内核级线程,线程切换在用户态就可以切换
>
> 内核级线程是在核心态进行完成的,**内核级线程才是处理机分配的单位**

用户级线程和内核级线程,线程切换在用户态就可以切换,**在线程池中管理**

内核级线程是在核心态进行完成的,内核级线程才是处理机分配的单位

1. 一对多模型 一个内核级线程对应多个用户级线程 `容易发生阻塞,并发性不高但切换效率比较高`
2. 一对一模型 则一个内核级线程对应一个用户级线程 `并发性比较高,但是切换的所消耗的资源较高`
3. 多对多模型 比如三个用户级对应两个核心机线程,`对以上两个进行了优化,用适当的资源做更多的事`

### 进程调度算法 各种各样的调度算法

前提 因为**内存资源有限**,**更好的处理任务,**有的时候无法将用户的作业全部放到内存当中

### **高级调度**(作业调度)

> 将合适的作业调入内存中,并为其创建进程

按一定原则在外存的后备队列中放到内存中等待处理机处理

### **中级调度**

将暂不能运行的放到外存,当内存空间充足后,再重新放到内存当中 为了**提高内存利用率和系统吞吐量**,

又重新引入 **就绪挂起和阻塞挂起**两个状态,

### **低级调度**

> 频率最高 给进程分配一个处理机进行操作

频率`最高` 从`就绪态`到`运行态`

- **主动放弃处理机资源 ** 正常终止或者有 io 设备阻塞或者内部发生错误
- **被动放弃处理机资源** 有更紧急的事需要处理,时间片用完了,更高优先级的队列进入

低级调度在`接受原语操作`是不可中断的

- 非剥夺调度方式
- 剥夺调度方式

新的进程环境的恢复和旧的进程环境数据的保存

进程环境的切换是有代价的,尽量不要进行频繁的进程切换

### cpu 利用率

> 进程切换时需要花很长的时间的,进程切换是有代价的,并不是越多越好
>
> 1. 对旧的进程需要保留之前的信息
> 2. 同时也要恢复新的进程的进度信息

> 如何评比 CPU 利用率,还有系统吞吐量的对比
>
> cpu 忙碌的时间/cpu 总的时间

周转时间是指 作业被提交到系统到作业完成的时间间隔

个人 作业完成时间减去作业提交时间

带权周转时间和周转时间都是越小越好

$$
作业周转时间/作业实际运行时间=作业完成时间 - 作业提交时间/作业实际运行时间
$$

等待时间,指的是**进程/作业等待时间(建立进程,进程被实现)**,等待时间越长,满意度越差

响应时间,从用户提交到首次产生响应发生的时间

### 调度算法

> 需要考虑到达时间,再来考虑调度算法,都是从就绪队列里面查找作业

- 先来先服务算法 FCFS(fist come first serve) **对长作业有用**
  - 公开,公平,但平均周权时间较长
  - 按顺序进行服务 长作业有利 短作业不利 但`不会造成饥饿`
- 短作业优先算法 SJF (shortest job first) **对短作业很有用**
  - 非抢占式的短作业优先算法
  - 短作业有限 短作业有利 长作业不利 会造成`长作业饥饿`
  - 也有抢占式的最短有限度算法
- 高响应优先算法 **根据响应比来进行计算**
  - **考虑作业所需时间和提交作业的时间**
  - 响应比 = (等待时间+所需服务时间)/所需服务时间
  - 因为等待时间越长,**响应比也会越来越高**.
  - `不会导致饥饿`
  - 只有进程主动放弃时才可以进行调度
- 时间片**轮转**算法 **每个作业都有时间操作**
  - 给每个用户都安排一个时间片 公平的轮流的为各个进程进行服务
  - 肯定是抢占式算法
  - 时间片不能太大 用户需调试时响应时间太长 也不能太小进程 切换资源浪费
  - 不会导致饥饿 会平均的给每一个进程一个时间片 时间片结束后就会被强制中断,通过**时钟装置来进行控制**
  - 可以与其他算法一起运行,根据不同的时间片进行分配处理
- 优先级调度算法 **判断优先级来进行安排作业调度**
  - 根据不同的优先级来安排不同的队列类型
  - 根据优先级来进行判断
  - 系统优先用户=>前台优先后台
  - 可能会导致低优先级饥饿

如果长时间不得到满足就提升优先级,如果长时间的占用就会降低优先级

- 多级反馈优先级算法
- <img src="/Users/huangruilin/Library/Application Support/typora-user-images/image-20220126112222488.png" alt="image-20220126112222488" style="zoom:50%;" />
- 多段优先级,和多时间片操作 平衡优秀,可能会导致饥饿.

### 进程同步性

又称之为直接制约关系 是用来协调进程之间的关系

进程具有异步性,因为进程都**是动态的以一种不可预知的方式向前推进的**

并不清楚进程是怎样进行推进的,谁快谁就先执行.

### 互斥共享和进程同步

有些资源是可以进行同时访问的,如扬声器

也有的资源必须是互斥访问,比如摄像头资源,在进入临界区的时候会进行上锁

### 临界资源

> 分为抢占式剥夺机制,和非抢占式剥夺机制

在一个时间段内只允许一个进程使用的资源的方式称之为临界资源

内核程序临界区一般用来访问某种内核数据结构的

进程在操作系统处理机资源的临界区域,分为多个阶段

- `空闲让进` 如果临界资源没有人进去则进程可以使用临界资源
- `忙则等待` 只能允许一个进程进入,其他进程都需要进行等待
- `有限等待` 保证在一个时间段之后可以让进程进入临界资源区
- `让权等待` 释放处理机 防止等待

### 单标志法

**每个进入临界区的权限只能由另外一个释放的进程给予**

因为只能由上一个进程赋予权限,最多时刻**只有一个资源访问临界区**

### 双标志先检查法

再标志一位 用来判断进程是否想要进入临界区的意愿

开关中断

### 双标志后检查法

### Person 算法

## 信号量机制

### 可以用一个变量标志,系统中某种资源的数量

原语,不可中断,必须一气呵成.

初始化,P 操作和 V 操作,三种方式.

## 管程

信号量编写困难,不易实现,易出错

局部于管程的数据结构说明,每次仅允许一个进程在管程内执行某个内部过程

### 死锁问题

资源访问是`互斥`的,`不可剥夺`只能通过自我放弃 `请求和保持访问` `资源循环`等待

对系统资源的争夺

发生死锁一定是有循环等待的,但循环 不一定发生死锁

循环等待的问题,卡在一个位置,都处于死锁状态

`并发` 因为竞争资源 导致各个进程无法推进的现象

`饥饿` 长期拿不到用户所需要的资源

`死循环` 过程序在执行过程中一直长久的跳不出某个循环

`死锁和饥饿`是操作系统应该解决的问题,`死循环`是`用户需要解决`的问题

## 如何避免死锁问题

### 死锁的预防

- 破坏互斥
  - 有的时候必须要保持互斥的状态
- 破坏不可剥夺
  - 反复申请和释放会提高系统的开销
- 破坏请求和保持
  - 静态分配方案 一次申请自己以后所有的资源
  - 资源利用率会浪费降低
- 破坏循环等待
  - 顺序资源分配 按照编号递增的顺序去请求资源

### 避免死锁

- 银行家算法 先满足一个进程
- 安全序列

### 死锁的检测和解除

如果可用的资源数可以满足进程的进行下去,则是不会发生死锁的

## 内存

> 2 的 10 次方是 1k 2 的 20 次方是 1m 2 的 30 次方是 1g

数据需要提前取出放到内存中才会被 cpu 处理

`逻辑地址和物理地址`跟`相对路径和绝对路径`差不多

编译语言是指从高级语言到机器语言的过程

### 生产者消费者问题 在乎互斥和同步的问题

只有在生产者,生产完之后才可以让消费者进行消费

临界资源是互斥访问的,也就是说放入和取出是完全互斥的.

管道通信也是完全互斥的,

### 死锁 饥饿 死循环 都会无法保障程序正常的发生

死锁 两个或者两个以上的进程 发生死锁

饥饿 一个进程长时间无法得到满足

预防死锁 破坏死锁的一个或两个条件 ,

避免死锁,避免系统进入不安全的状态

只有对必须互斥使用的资源的争抢才会获得死锁

### 数据的存储和运算

计算机对于数据的存储和运算,都是通过二进制数据来完成的

使用8个二进制位   表示一个byte位 字节

1. 存储数据的单位是字节

2. 每个字节有8个二进制位

### 人机交互的方式

1. 命令行  速度快,执行速度快 **但是比较麻烦**
2. 图形化  缺点  消耗内存, **运行速度慢**

### 盘符切换的方式

直接输入`D:`就可以切换到D盘进行操作

### bin目录

快捷方式只是**记录了软件的位置**,让我们**可以快速的启动软件**

.exe程序属于可执行程序,可以直接启动

### path环境变量

系统中的大管家,帮助我们记录了很多的完整路径

如果运行一个程序,除了会在当前目录下面寻找该程序

系统还会到path中查找,帮助我们很快的启动程序,**配置系统变量**

### 计算机分为硬件和软件

硬件分为 **cpu**  **内存  存储设备  输入设备 输出设备 其他设备**

软件分为  **操作系统  应用软件**

硬盘分为 **机器(HDD)**和**固态(SSD)**  **混合(SSHD)**  **硬盘会进行存储**的

内存  负责硬盘上的数据和CPU的数据交换  **(断电后会失去数据)**

### 什么是软件 

> 按照特定顺序组织的**计算器数据**和**指令的集合**
>
> **算法是指令的合集**

分为两种交互方式

1. **图形化界面**  简单直观  使用者容易接受
2. **命令行cli界面**   比较麻烦 需要记忆一些指令

### 计算机语言简史    逐步变得易读

1. 机器语言  使用**二进制来进行编写**,**机器语言是计算机唯一可以识别的语言**
2. 汇编语言  使用**指令集语言**来编写   将一些机器语言汇总成一个指令  
3. 高级语言  使用**接近日常英语的指令编写程序**  独立于基奇的,但是需要使用编辑器或者解释器,需要转换为**机器语言才会被识别和执行**

C语言的**学习难度比较高** C++  **比较难学的语言**  python **易学的语言**

Go语言  夹缝中生存,已成为**云计算的中的唯一语言**

**没有最好的语言,只有最合适的语言**,你其他语言再牛逼,只有js才可以在浏览器中运行
