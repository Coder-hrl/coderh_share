> 为什么this.state里面的数据为什么是不可变的,只能通过覆盖进行响应式改变
>
> 为什么要保证**state里面的数据是不可变型**呢,就是怕**引用类型**
>
> 如果只是改变数组或对象里面的值,那么是不会发生改变的,因为他的**引用地址是不变的**
>
> 又因为在**pureComponent 和memo函数中对数据都是进行的浅层比较**,因为改变的是原数组,前后的**引用地址**不变,所以在使用pureComponent不会按照之前那样进行更新
>
> **shouldComponentUpdate和pureComponent和memo**都是为了判断组件是否更新

1. 如何在state数组里面添加数据

   先在外面改变state里面的数组,然后再将this.setState再进行覆盖赋值

   ```js
   this.state.firends.push()
   this.setState({
     firends :
   })
   ```

2. 使用一个新的数组来保存这个数据

   ```js
   const newArr = [...this.state.firends]
   // 还是通过这样创建一个新数组比较稳定,非常稳妥
   // 通过 newArr = this.state.friends.push('jjj')  是不可以的
   ```

3. pureComponent 会自动对组件的数据进行浅层比较

还是使用 `const newFriends = [...this.state.friends]`,浅拷贝就可以

不需要进行深拷贝,让React知道发生改变就可以

也可以是用`Obejct.assign()`

###### ref 有些时候我们需要操作原生属性 、

> 可能和Vue里面的ref一样,直接操作子组件里面的方法或数据

ref可以等于字符串,对象或者函数,使用字符串的方式,不推荐

```js
<h2> </h2>
this.refs.名字.属性操作
```

###### 使用createRef 方法,

```js
constructor(){
  this.title = createRef()
}
ref={this.title}
```

###### 使用函数方法

```js
constructor(){
  this.titleEl = null
}
<h2 ref={agr=>this.titleEl = arg}> </h2>
```

##### 用的比较多的还是,或者使用useRef

```js
constructor(){
  this.titleRef = createRef()
}
<Greent ref={this.titleRef} />
//   可以拿到组件对象
```

#### 受控组件和非受控组件都是与表单有关系的

**认识受控组件**

```js
<form onSubmit={e=>}>
</form>
//event.preventDefault()
```

通过React中constructor里面state保存表单组件里面的数据,通过onchange触发函数来修改改变state,我们可以使用`value={this.state.userName}`