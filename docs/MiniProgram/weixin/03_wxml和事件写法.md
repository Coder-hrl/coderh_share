---
title: wxml详解和事件
---

## WXML基本格式

类似HTML需要**严格闭合**,对**大小写敏感**,可以写成**单标签**或者**双标签**

### 小程序和Vue一样使用mustache语法

使用**{{}}**的方式来展示js中的**data**属性

### wx:if

这个元素是否进行**渲染**

### wx:for

会自动出现两个属性,一个是**item**,另外一个则是**index**

**在block标签上面**进行wx:for

#### Wx:for-item和wx:for-index这两个属性是可以进行重命名操作

通常用于遍历数组,注意其中的**wx:key**是不需要使用{{}}的,直接会被找到item身上

#### 何时使用*this这个关键字?

**保留关键字*this**代表在for循环中item本身,这种表示item本身是`item本身`或者`唯一的字符串`

或者使用wx:key=“{{index}}”,如果只是获取到item里面的值,无需使用**mustache**语法

### WXS

> 是小程序的一套脚本语言,结合WXML,可以构建出页面的结构

#### 为什么使用WXS?

因为在WXML中是不能直接调用Page/Component中定义的函数的

但是在某些情况,我们可以希望使用函数来处理WXML中的数据

**我们不可以直接调用定义在js中的函数在mustache语法中**

如果需要对返回的数据进行处理一遍的话,第一种方案是

1. **手动进行拼接**
2. **在js中将所有数据处理好之后使用**
3. **使用WXS方法**

#### 缺点和限制

- 不依赖运行时的基础库版本,可以在所有版本中运行
- 不可以调用其他JavaScript中定义的函数,也不能调用小程序提供的API
- 由于运行环境,IOS会比JavaScript运行速度快2-20倍,在android中无差异

#### 第一种写法 标签

```js
function formatPrice(price){
  return "$" + price
}
module.exports = {
  formatPrice
}
```

#### 第二种写法则是使用mjs文件

> 注意所有的导出必须要使用Commonjs,ES module并不支持

### 事件执行

> 事件是视图层到逻辑层的通讯方式

我们可以**将用户的行为反馈到逻辑层**进行处理

| 类型       | 效果               |
| ---------- | ------------------ |
| touchstart | 手指触摸           |
| touchmove  | 触摸后移动         |
| touchend   | 触摸动作结束       |
| tap        | 手指触摸后马上离开 |
| longpress  | 长按               |

#### event属性

| 属性          | 功能           |
| ------------- | -------------- |
| type          | 类型           |
| target        | 触发事件的元素 |
| currentTarget | 处理事件的元素 |

在冒泡事件中有的时候是父元素进行委托处理使用

target属性是触发事件的元素

currentTarget则是拿到处理触发事件的元素

##### touch属性

**多指触摸**的时候就会产生多个点,这些点就会放到touches里面中

##### data-* 

> 是event中参数传递的方式,通过event.target.dataset里面的属性
>
> 或者是通过event.currentTarget中触发得到的

#### mark:*

> mark中target中的mark和currentTarget的mark会进行一个合并

使用的mark的方式也可以传递这些值

**注意:**mark是放到**event对象**中,而`dataset`则是放到**event.target对象**中

#### catch

catch可以阻止事件冒泡进一步的传递

### 组件化思想

> 小程序中的组件化和**React**和**Vue**都是极其相似的,**完全是互通**的
>
> 会造成重复代码,对后期维护极其困难,对代码结构非常难以理解
>
> 在微信小程序中如果使用Component的话,请在**json**文件中使用
>
> **Component设置为true**的方式

存在**内置组件**和**自定义组件**,

Component中也是有四个文件的,在**引用一个自定义组件的时候,需要在json文件中声明**

**自定义组件也是可以引入其他的自定义组件的**

#### 组件的内部样式是否影响到外部组件?

组件内部影响不到外部组件

外部组件使用class的样式只会对外部有效,对内部不会生效

外部使用标签选择器,会影响到内部组件的使用(不建议使用id和标签选择器)

是存在options属性的,可以配置是否**进行样式隔离**

```js
Component({
  options:{
    //是否采用样式隔离
    styleIsolation:""
  }
})
```

#### 组件间的通信

> 组件内展示的内容,并不是写死,而是有父传递给子

组件内是存在两种数据类型的,是**properties**和**data**两种方式

一个是props,另外一个则是组件内部使用的data数据

```js
properties:{
  title:{
    type:String,
    value:""
  }
},
data:{
  name:""
}
```

##### 自定义事件传递的方案

1. 在子组件中**触发**一个函数,使用**this.triggerEvent()**来发送事件
2. 在父组件中使用**bind:事件名** =` ""`
3. 然后传递到了数据,可以从event.detail拿到数据

与**React**和**Vue**对比

**React:**

1. 在**父组件中声明一个函数**,同时用一个函数来响应`emit(概述)`之后的事件
2. 在**props中取到这个函数**,在参数中放置需要传递的值
3. 在需要触发的时候触发这个函数,**父组件在参数中直接去取**

**Vue:**

1. 在子组件中触发一个函数,使用**this.$emit**或者使用**emit**来传递这个函数
2. 在父组件中直接使用@外加emit的事件名 = `“”`
3. 父组件直接从**参数中去取**

如果去取properties里面的值的时候

我们需要使用**this.properties来取到这个里面的值**

#### 插槽的使用

#### Component构造器