#### 类的三大特性

封装继承多态

**多态的前提是继承**,(实现接口) 2. 必须有父类引用,指向子类对象

不同数据类型实体,提供统一的接口,但是出现不同的表现行为

###### ts对没有限制的代码加上静态类型检测

不同的数据类型进行同一操作,表现出不同的行为,就是多态.

###### JavaScript中是一定存在多态的

##### 对象字面量增强

1. 属性的简介

```js
let name = "obj"
var obj = {
  name,
  say(){}
  [key]
}
```



1. 方法的简写

#### 计算属性的简写

##### 使用[]的方式,实现对象里面的计算属性增强,可以让键值key引用外部的值

#### 解构拆包       都是可以添加默认值的

数组和对象都是具有解构语法,可以快速的拆分对象和数组 非常常用

**在数组结构中,他的解构赋值是具有严格的顺序要求的**

解构也是可以写默认值的 const [name1 , name3=“default” ] = names

###### ...剩余语法和展开语法

###### 对象是根据key来获取对象值的

对象**重命名** const { height:Wheight } = obj

##### 应用 在函数的参数中进行解构

```js
function ({ id , x , y }){
 	console.log(id,x,y) 
}
```

自动对函数其解构赋值,在实际开发中经常使用

****

##### 手写call和apply函数

Function.prototype.call(thisArgs,...otherArgs)

```js
thisArgs = (thisArgs==null||thisArgs==undefined)?window:Object(thisArgs)
Object.defineProperty(this.Arg,"fn",{configurable:true,ennumberable:false,value:fn})

// 使用delete 方法 可以进行删除属性
delete fn
```



封装组件,全部拆分

##### Bind函数 会返回一个绑定this之后的新的函数

```js
return ()=>{} //因为是箭头函数,所以此处的this是函数的this
```



###### 先将基本功能函数完成,然后再一点点的新增功能

#### ECMA新描述概念

 词法环境 **一般由环境记录和外部环境一起构成,在函数声明的时候,代码块语句,try-catch,当代码执行的时候,就会被创建出来**

 暂时性死区,存在变量提升,但是存在暂时性死区

**只有在执行到之后才可以被访问**

#### 环境记录   ER  (environment record)

##### let const 基本的使用

var 变量提升,没有块级作用域,变量重复声明,定义到**window**对象上

let  暂时性死区,块级作用域,不可重复声明

const 暂时性死区,赋值后无法修改(指内存地址),不可以重复声明,块级作用域

重复声明会造成安全隐患,防止后期意外的修改变量名字

##### 多学习多种编程语言,从多语言的方面,去看待一个事情

name会在window中是存在的,会发生意料之外的错误

我认为暂时性死区的意思就是

1. **变量事先已经在词法作用域中被创建出来了,但是不可以被访问.**

2. **直到执行到这个代码之后,才可以被访问**

查看一个变量是否可以被访问,我们需要使用代码的执行顺序

函数内的变量,应使用变量内部的变量,内部不存在,才会随着作用域链进行查找

##### 编写代码,应该是将自己内心的想法通过代码表现出来

##### let const 保存在哪里呢

在 var 中,他的变量和值保存在window对象中,变量只有函数作用域

**let和const声明的变量, 是保存在词法作用域中** ,并不是绑定到window对象上

{}就是被称之为一个代码块,在React中,代码块的使用的是非常常用的

let和const声明的变量 会形成属于自己的块级作用域

##### 使用class声明的类,也是具有块级作用域的

函数在块级作用域里面,也是可以访问的

##### 块级作用域的作用?

1. 在for循环,可以精准的拿到每一个值
2. 在开发中更加便利,不用担心变量声明重复导致报错

代码块中也是存在属于自己的环境记录信息的

**会事先放到单独的词法环境中,直到被执行,单独的词法环境被销毁**

然后放置到统一的词法环境中进行执行

##### 如何自己实现块级作用域

**使用立即执行函数,使用函数作用域的形式,以函数对象的形式来保存i值**

函数不会被销毁,是因为在被Dom元素所引用,变量不会被销毁,是因为被函数所引用

##### 直接选择const 如果自己确定需要修改这个变量的话,再去决定选择let

在其他语言中也是这样进行约定修改的.