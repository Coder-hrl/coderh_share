### this面试题

#####    .  语法的优先级是非常高的 是高于()的其他优先级的

`所以(obj.say)()与obj.say()本质一样`

但是 `(b =obj.say)`则是赋值语句,属于默认绑定

- 对象是没有作用域这个概念的
- 箭头函数 他是不绑定this的,但是内部的this是上层函数作用域,

### 深入浏览器运行原理 

##### 网页解析流程

DNS dotain name system 域名解析系统

因为ip地址不容易记忆,而且易发生改变,所以使用简单易记的域名

输入url,判断url是否合法,转义,**请求服务器的静态资源**

##### 浏览器渲染原理

- Blink内核   webkit内核   浏览器 排版引擎

通过浏览器内核,渲染html页面和css页面,解释js语言

堵塞不会影响加载流程,但是会去影响解析

**加载和解析**HTML,生成**Domtree**,然**后解析CSS样式,**生成CSSOM,**规则树**

生成一个**渲染树**,然后根据实际窗口,开始**计算元素位置和大小,偏差**

然后生成**布局树**,浏览器开始根据**布局树进行页面绘制**

HTML和CSS是并行进行加载和解析的,但是会延迟生成(render Tree)渲染树

##### 重绘和回流重排

> 修改样式一次性修改完成,建议使用动态添加class
>
> 避免频繁操作Dom

回流的性能损耗是高于重绘的

重绘和回流的区别就是==>

​					需不需要重新计算**元素大小和位置**,页面是否需要重新布局

改变dom结构,删除,新增节点,改变节点大小

窗口的resize事件,改变窗口尺寸

使用**getComputedstyle**方法,重新获得页面的布局和计算

使用position:fixed和absoluate,脱离标准流,减少Dom回流

##### 特殊解析    `合成图层`

> 绘制多个图层,最后再进行合并,z-index就是看谁在最上面.
>
> 图层虽然会提高渲染速度,但是不要滥用多个图层,会以内存管理为代价
>
> 这是**浏览器**进行的解析优化

composite 合成  将元素绘制到多个图层中,然后进行图层合成,GPU加速控制

标准流会在一个图层中进行渲染 脱离标准流会在其他图层进行绘制

1. 3D transform 
2. Video和Canvins iframe
3. 3D图形转换      position:fixed 会生成新的图层
4. animation 进行动画渲染  transition 执行过渡动画
5. will-change css属性,一个实验性的属性,提前告诉浏览器,将会发生什么改变

##### 合成和性能优化

##### defer同步加载和async异步加载

在现代开发中,js脚本更重,我们需要做到该下载下载,该解析解析

执行顺序,自上而下,遇到CSS文件,依次下载,不影响解析

但是遇到js则会停止解析,进行阻塞,等到下载执行结束之后才会往下执行

1. 带有defer的属性,会先去下载,等到所有的Dom元素解析DOMContentLoaded事件之后之后,才会去加载执行
   - 如果多个defer的脚本是能正常按顺序进行执行的 (会提高性能的)
2. async,异步进行下载js文件,谁先加载完谁执行,也不阻塞Dom构建
   - 如果多个async脚本,谁先下载完,谁执行是不会保证按照顺序进行执行的,以不可预知的方式往前冲   		对Dom没有依赖
   -  它保证每个js文件是完全独立的
3. 有些浏览器做了一些优化,不等所有的Dom解析之后,可以边解析,边render

### 深入JavaScript运行原理

> JavaScript是一个高级程序语言,需要通过解释器转换为(字节码)汇编或者(机器码)机器语言
>
> 首先进行parse解析,然后进行AST抽象语法树,进行解释转换字节码或者优化的机器码                   `字节码和优化的机器码都是可以进行相互转换和执行的`
>
> 如果一个函数多次被调用,就会对其进行优化,转换为机器码

##### 深入V8引擎原理

webkit包含webCore和javascriptCore两部分

JavaScriptCore是用来解析执行js的

1. V8引擎被Chrome和Nodejs中使用,本身是跨平台的
2. 可以自己执行,也可以被内嵌到其他C++应用程序中

如果被标识为热点函数,就会被TuraboFan转换为机器码,然后能够更优的执行

进行词法分析器,转化为token序列,分词的过程,之后对代码进行语法分析(parser)执行,然后开始对代码进行转为字节码和机器码的过程,执行

**JVM java虚拟机**

##### 很多概念是一样的,不过描述的方式却不一样

GO(global Object) ,VO(veriable Object)