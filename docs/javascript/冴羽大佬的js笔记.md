---
title: 冴羽大佬的js笔记
---

### 作用域

作用域是程序源代码中定义变量的区域，JavaScript 采用的是**词法作用域（静态作用域）**

#### 词法作用域

函数的作用域是在定义的时候所确定的

#### 动态作用域

函数的作用域在函数调用时才决定

如以下例子

```js
var value = 1;
function foo() {
	console.log(value);
}
function bar() {
	var value = 2;
	foo();
}
bar();
```

在以上的例子中，我们打印到的结果是 1，而不是 2

如果是动态作用域的话，如果在函数内部找不到 value，会去**调用的函数作用域中**去寻找

**JavaScript 函数的执行用到了作用域链**，这个**作用域链是在函数定义的时候创建的**。嵌套的函数 f()定义在这个作用域链里，其中的变量 scope 一定是局部变量，不管何时何地执行函数 f()，这种绑定在执行 f()时依然有效。

### 执行上下文

JavaScript 并非一行行的分析和执行程序，而是一段段地分析执行，在执行代码之前，会先进行**预解析** 工作

#### 可执行代码

会分为三种，全局代码，函数代码，eval 代码

#### 执行过程

在执行一个函数的时候，**会创建一个执行上下文，并压入栈中**

当**函数执行完毕**之后，再将**函数的执行上下文从栈中弹出**

### 变量对象

每个执行上下文包含了三个重要的属性:

- 变量对象(Variable object,VO)
- 作用域链(Scope chain)
- this

变量对象存储了在上下文定义的变量和函数声明

#### 全局对象

1. 在非严格模式下，可以通过 this 引用，在 web 端，window 就是全局对象
2. 全局对象是由 Object 构造函数实例化的对象
3. 全局对象中预定义非常多的属性和方法
4. 全局变量存储到全局对象中
5. 所有的作用域链查询的最终目的地就是全局对象

`function` 开头的函数会进行函数提升，以 `var` 开头的变量则会进行变量提升

在进入执行上下文时，首先会处理**函数声明**，**其次会处理变量声明**

如果**变量名称跟已经声明的形式参数或函数相同**，则**变量声明不会干扰已经存在的这类属性**。

### 作用域链的查找顺序

1. 首先会先从上下文的变量中寻找，有则返回
2. 然后会从词法作用域的父级进行查找，有则返回
3. 迭代查询到全局上下文，无则报错

这样由多个执行上下文对象构成的链表被称之为作用域链

函数的 this 是在运行时所确定的，函数的**变量查找顺序则是在定义时确定的**

箭头函数是没有 this 的，他的 this 是**由外部函数的 this 所确定的**

#### 函数激活

当函数激活时，进入函数上下文，创建 VO/AO 对象，并添加到作用域链的前端
