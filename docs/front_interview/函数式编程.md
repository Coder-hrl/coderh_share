---
title: 函数式编程
---

[原文地址](https://juejin.cn/post/6844903936378273799)

# 什么是函数式编程

函数式编程是一种**由“结果导向”的编程范式**，他决定我们以哪一种放来和规范去组织自己的代码，是一种编程思想

“学习函数式编程真正的意义在于：让你意识到在指令式编程，面向对象编程之外，还有一种全新的编程思路，一种用函数的角度去抽象问题的思路。学习函数式编程能大大丰富你的武器库，不然，当你手中只有一个锤子，你看什么都像钉子。”

> 早在 1950 年，函数式编程已经出现在大家视野中，函数式编程是一种以函数使用为主的软件开发风格
> 函数式编程和组件化思想很相似，封装单个功能纯函数实现简单需求，将多个纯函数组装实现复杂需求

前端中，ES6 中添加箭头函数，React 中使用函数式组件，使用 memo，useEffect 等 hook，Vue 中 componentsAPI 都代表着函数在前端领域非常重要。

函数式编程是除了命令式编程和面向对象编程的另外一种编程思想

当实现一个功能时，`命令式编程`

需要一步步的去实现一个功能，包括但不限于`手动循环`，`声明变量`，同时过程中掺杂大量的逻辑，通常需要**从头读到尾才知道它具体做了什么**

而对于函数式编程则通常**使用一个函数来完成这些复杂的逻辑代码**，着眼点是**函数**，而不是**过程**，他强调的是如果通过函数的组合变换去解决问题，而不是我怎么样去编写条件语句去解决问题。

`封装成可复用`的函数，思想逻辑是如何将`不同功能的函数`组装起来去解决一个问题

## 函数式编程的特点

> 通过将函数以`输入输出的方式`组装起来,实现一个`数据`或者`功能`，它其实就是强调在编程过程中把更多的关注点放在如何去构建关系。

1. **拥抱纯函数，隔离副作用**
2. **函数是 Js 中的"第一公民"**
3. **避免对状态的改变(不可变值，单向数据流)**

声明式编程和函数式编程不关心过程，只关心最终的结果，我们不再关心逻辑的具体实现，而是关心如何将**函数“组成”**来实现功能

有点类似于流水线工作，每个流程都是清楚的输入和清楚的输出，如橙子的去皮，压榨和滤渣几个环节

函数是一种`描述集合和集合之间的转换`关系，输入通过函数都会返回`有且只有一个输出值`

函数实际上是一种关系，通过函数将输入值转换为想要的输出值

在编程中也是需要处理这些`关系`，所谓的`编程工作`也不过就是找一种关系

函数在流水线中可以称之为一个小过程，数据可以不断的从`一个函数的输出`流入另外`一种函数的输入`，最后输出结果

## 函数式编程的特点

### 函数是一等公民

> 函数则可被称之为可执行的对象，一等公民意味着函数在 JS 世界中拥有最高的自由度
> 任何语言想要实现函数式编程，都需要满足一个条件，支持函数是第一公民

这也是函数式编程得以实现的前提，这意味着函数与变量一样都是可以通过参数来进行传入

1. 可以被当作参数传递给其他函数 例如**回调函数**

```js
function foo() {
	console.log('first');
}

function test(fn) {
	fn();
}
test(foo);
```

2. 可以作为另一函数的返回值 **实现了函数的柯里化**

```js
function foo() {
	return function () {
		console.log('first');
	};
}
const f1 = foo();

// 此时f1则是一个函数
f1(); // 我们可以通过这样去调用它
```

3. 可以被赋值给一个变量

```js
const foo = () => {
	console.log('first');
};
```

### 声明式编程

函数式编程大多时候都在声明我需要做什么，而非怎么去做，可读性较强
一个编写好的函数，同时也符合单一职责原则，低耦合高内聚，我们只需关注函数的功能和参数即可

### 懒惰执行

函数只在需要的时候执行，既不产生无意义的中间变量

### 无状态和数据不可变

**数据不可变**，要求所有的数据都是不可变的，如果你想修改一个对象，那你应该创建一个新的对象用来修改，而不是修改已有的对象
**无状态**，强调一个函数，不论何时何地的执行，都应该是传入相同的输入，一定会给出相同的输出，完全不依赖外部状态

可不变不是要消灭变化，而是要控制变化的出现，**将程序中可变和不可变拆分**，并将可变部分抽分封装

const 对值类型有非常重要的作用，但实际上对于引用类型帮助并不大，但他却可以直接确立声明的类型

`不可变数据的重要设计实践`，**对于值类型使用 const，对于引用类型使用深拷贝而不是修改**

对于简单的数组和对象，使用 JSON.parse(JSON.stringify())创建出一个副本来

但 当数据规模大，数据拷贝行为频繁时，拷贝将会给我们的应用性能带来巨大的挑战

我们可以引用 Immutable.js 提供的一系列的 api，这些 Api 帮助我们确保数据的不可变性

### git commit 快照

快照的本质是对索引的记录。

在生成快照的过程中，对于那些没有发生变化的文件，git 会沿用他们固有的索引。

Git 快照保存文件索引，而不会保存文件本身。

变化的文件将拥有新的存储空间+新的索引，不变的文件将永远呆在原地。

## 纯函数 (pure function)

> 纯函数才是真正意义上的函数，它意味着相同的输入，永远会得到相同的输出，且永远不会产生副作用
> 配合使用类型签名能够更好的理解这个函数
> 输入只能够以参数形式传入，输出只能够以返回值形式传递，除了入参和返回值之外，不以任何其它形式和外界进行数据交换的函数。
> 纯函数从函数中的上下文中脱离出来，这个则是与函数中 this 概念完全相对立的。纯函数是高度灵活的函数，它的计算概念在任何上下文中都是成立的
> 纯函数并不是为了约束而约束，而是为了追求更高的可确定性，让我们编写出更清晰，易管理的代码

- **无状态**，一个函数应该是确定的输入，一定会有确定的输出，同时不依赖外部的状态
- **数据不可变性**，一个函数应该是没有任何副作用的，并不会对外面的变量产生影响，避免因为意外修改共享状态带来的问题，坚持数据不可变性，也代表了**坚持纯函数，避免副作用**
- **显式数据流**，除了入参和返回值之外，不以任何其它形式和外界进行数据交换的函数。

```js
// 像以下的函数则会根据作用域链去查询变量，则不可称之为显示数据流
function () {
  return a + b
}
```

### 副作用

如果一个函数除了计算之外，还对它的执行上下文、执行宿主等外部环境造成了一些其它的影响，那么这些影响就是所谓的”副作用”

就算是 console.log(),也修改了浏览器的控制台，对外界产生了影响

副作用并不是一个毒药，如果一个功能想要进行 xhr 数据交互，或者与外界链接的设备进行交换，副作用是不可缺少的

对于一个功能的实现，纯函数仅仅是帮助我们更好的管理和应用代码，并不会影响功能的外部行为，而关注代码本身的，仅有程序员自己

### 优点

- **便于测试和优化**，减少函数的不确定性，由于纯函数对于相同的输入永远会返回相同的结果，这样的代码健壮性会更强
- **可缓存性**， 我们可以提前缓存函数的执行结果，比如 React 中 useMemo 等函数
- **自文档化**，由于纯函数没有副作用，所以其依赖很明确，因此更易于观察和理解
- **bug 减少**，使用纯函数意味着不存在指向不明的 this，不存在对全局变量的引用，对参数的意外修改

## 流水线的构建

> 函数式编程中最重要的两点，无疑就是柯里化(加工厂)和函数组合(流水线)

### 加工站--柯里化

将一个多元的函数，转化为一个依次调用的`单元函数`,因为柯里化处理的结果刚好就是单输入的。

通常，我们在实践中使用柯里化都是为了把某个函数变得单值化，这样可以增加函数的多样性，使得其适用性更强

```js
f(a,b,c)=>f(a)(b)(c)
```

**我们可以用高级柯里化去实现部分函数应用，但是柯里化不等于部分函数应用。**、

## 组合

> 将实现一个功能所需的函数组合在一起形成一个组合函数，不要把计算中间态暴露出去
> 将其像一个流水线一样组合在一起，每一个流程就是一个函数，但是流水线内部对外是透明的

### 流水线--函数组合

> 有纵多单一目的的小程序，一个程序实现一个功能，多个程序组合完成复杂任务

组合函数，也称之为`compose`,指的是将一个输入，通过组合`各类函数从而达到理想的输出`

最完美的是，这些函数都是非常简单的纯函数，你可以随意组合，随意拿去用，不用有任何的顾忌。

而最终产物只会穿梭于不同的工序之间，而不会暴露在流水线的外部。

链式调用的每一步都会像传送带一样，把上一步的输出作为下一步的输入传送出去

### 函数组合的好处

我们可以将多个函数组合起来，让代码变的简单而富有可读性，同时可以通过不同的组合方式，可以轻易的组合除其他常见函数

pipe 创建一个正序的函数传送带，而 compose 则用于创建一个倒序的函数传送带

### 使用的要点

函数组合中函数要求单输入，就是中间的函数一定是`单输入`的

## 影响函数的因素

执行结果的因素会随着执行上下文的改变，函数执行宿主的变化，系统时区的变化，甚至是外链温度和湿度的变化，都是会影响 JS 的输出的

**它并不像一个数学方程式**，在任何时候，一个 x 仅有一个 y 值来进行对应

而**数学化的 Js 函数则是完全相等一个纯函数**

不关乎外部的变化，无法影响外部，也无法被外部影响,如以下这个例子

```js
// 只要两个函数的入参相同，那么它的返回值就是固定的
function foo(x, y) {
	return x + y;
}
```

## 函数柯里化

函数柯里化本质上是将多个参数的函数，通过 `return function` 的形式转为单参数的函数

为了解决以下问题

- 函数组合链中的参数对齐问题，pipe 函数须只接受一个参数
- 函数逻辑复用问题

### 理解函数中的元数

> 函数中的袁术，本质上将的是函数的参数的数量

在 js 中单元函数类似这种方式

```js
// 只传入一个参数的函数为一元函数
function add(x) {
	return x + 10;
}
```

> 函数组合链的函数总是一元函数，这是一个通用且广泛的约定，并不是一个死规定
> 有的时候，可以传入多个参数，但仅仅是第一个函数有此特权，其他仍要保持一个参数

允许保留原有函数的基础上，单纯通过增量代码实现柯里化

```js
// 定义高阶函数 curry
function curry(addThreeNum) {
	// 返回一个嵌套了三层的函数
	return function addA(a) {
		// 第一层“记住”参数a
		return function addB(b) {
			// 第二层“记住”参数b
			return function addC(c) {
				// 第三层直接调用现有函数 addThreeNum
				// 自定义操作函数
				return addThreeNum(a, b, c);
			};
		};
	};
}
// 借助 curry 函数将 add
const curriedAddThreeNum = curry(addThreeNum);
// 输出6，输出结果符合预期
curriedAddThreeNum(1)(2)(3);
```

## 总结

一个优秀的函数应该一个可靠、受控的黑盒，他应该总是将变化控制在盒子的内部，而不去改变盒子外面的任何东西。

我们只需将整个功能函数的入参和出参，明确的表示出来

### 优点

- 代码简洁，开发快速：函数式编程大量使用函数的组合，函数的复用率很高，减少了代码的重复，因此程序比较短，开发速度较快。Paul Graham 在《黑客与画家》一书中写道：同样功能的程序，极端情况下，Lisp 代码的长度可能是 C 代码的二十分之一。
- 接近自然语言，易于理解：函数式编程大量使用声明式代码，基本都是接近自然语言的，加上它没有乱七八糟的循环，判断的嵌套，因此特别易于理解。
- 易于"并发编程"：函数式编程没有副作用，所以函数式编程不需要考虑“死锁”（Deadlock），所以根本不存在“锁”线程的问题。
- 更少的出错概率：因为每个函数都很小，而且相同输入永远可以得到相同的输出，因此测试很简单，同时函数式编程强调使用纯函数，没有副作用，因此也很少出现奇怪的 Bug。

### 缺点

- 性能，函数式编程相对于指令式编程，性能绝对是一个短板，因为它往往会对一个方法进行过度包装，从而产生上下文切换的性能开销。
- 资源占用：在 JS 中为了实现对象状态的不可变，往往会创建新的对象，因此，它对垃圾回收（Garbage Collection）所产生的压力远远超过其他编程方式。
- 递归陷阱：在函数式编程中，为了实现迭代，通常会采用递归操作，为了减少递归的性能开销，我们往往会把递归写成尾递归形式，以便让解析器进行优化。

### 命令式编程和函数式编程的特点

对于任何的编程范式，只读数据都必须与可写数据共存的，如果没有可写数据的存在，那么这个功能将变的毫无意义

#### 命令式编程

> 关心整个过程

1. 这些具体步骤组成的命令序列，就是一段命令式程序
2. 每一步都很具体，需要自己去编写实现
3. 可以清楚的知道每一步做了什么
4. 更像是一锤子买卖，执行完之后，如果想实现相同的逻辑，只能靠复制粘贴

#### 声明式编程(函数式编程)

> 只关心输入和输出，并不关心内部如何实现，非常重要的概念，有输入和输出

1. 固定的输入，由特定的函数来返回结果
2. 只关心结果，并不关心内部如何实现
3. 对于外部，结果的实现是一个黑盒状态
4. 将功能封装，有固定的输入，有固定的输出
