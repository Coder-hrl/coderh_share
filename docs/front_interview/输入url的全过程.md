# 从输入 URL 到呈现页面过程

> 什么是正向代理，什么是反向代理？
> 正向代理对于服务端是透明的，服务器端并不知道真正访问的 ip 地址是谁（如 VPN，各种加速器）
> 反向代码对于客户端是透明的，客户端并不知道真正返回的是哪个服务器返回的（如负载均衡）
>
> ---
>
> 在 http1.1 下，会自动开启长连接

- 输入`url`：用户在地址栏按下回车，先检查输入的是关键字还是复合`url`的规则，如果是是没有 http 等前缀的话，会将其组装成完整的 URL 进行访问
- 检查缓存：首先会检查浏览器的缓存是否可用，如果是强缓存的话，会直接返回资源，如果是`no-cache`的话，会发送请求访问服务器，判断缓存是否新鲜，如果新鲜的话直接返回（注意不要给 html 设置 max-age，这样会很难触发更新）(会根据 html 中生成的`chunkId`来判断，其他资源是否新鲜)
- DNS 解析：如果协商缓存不可用的话，就会进行 DNS 解析，会通过迭代查询和递归查询解析`域名`来得到 ip 地址，会根据浏览器 IP 缓存==》操作系统 Hosts 文件==》本地 DNS 服务器 ==》根 DNS 服务器 ==》顶级 DNS 服务器 ==》 权威 DNS 服务器(使用的是 UDP 协议，在这个过程中，都会去查看该域名在 DNS 服务器中是否有映射，如果有映射会直接返回查询到的 IP)
- 建立 TCP 连接，根据 IP 地址，首先会进行三次握手后去建立 TCP 连接
- 发送 HTTP 请求时，会携带 cookie，和其他请求头等表示去请求 HTTP
- 发送 HTTP 请求中会进行慢启动，拥塞控制，快恢复等发送 http 报文段，会通过累计确认，校验和等手段来确认报文是完整，没有丢失和损坏的
- 负载均衡：服务器端网关收到 HTTP 请求后，可能会有一系列的负载均衡来进行处理，根据各个服务器的权重开始分发请求，通过`反向代理`分配给对应集群的服务器去执行
- 服务器返回响应：会根据请求头的`缓存标识`来判断缓存是否生效和请求头其他标识来按需返回信息，如果缓存生效返回 304 状态码，如果不生效的话，会返回资源和 200 状态码
- 当 HTTP 请求结束之后，会首先去判断是否开启了长连接`(connection:keep-alive)`是否到了超时时间，如果超过之后则通过四次挥手来断开 TCP 连接
- 浏览器会`缓存`响应头中 cache-control 中 max-age 和 no-Cache
  > 浏览器请求响应过程到此为止，开始浏览器渲染和解析
- 浏览器当解析到后缀名为 html 的文件时，从头到下开始解析，在解析过程中会根据`html标签`构成树类型的节点来构建 DOM 树
- 当在解析到 css 的时候，会根据 herf 地址去加载 css 文件，同时会根据 css 构建出 CSSOM 树，`注意加载不会阻塞html渲染，解析则会阻塞`
- 当在解析到`script`标签时，注意到遇到不带 async 和 defer 时，不会去进行异步加载，会阻塞 Dom 解析，如果是 defer 情况下会，在 Dom 渲染后才去加载 js
- 构建渲染树，浏览器会根据 Dom 树和 CSSOM 树构建出`render`渲染树,注意在此过程中，一定会发生重绘和回流这两个流程
- 布局，根据渲染树将 DOM 中每个节点渲染到屏幕上中的正确位置
- 绘制，根据渲染树，绘制出所有的节点，其中会采用一些方法来加速 CSS 渲染
  - 构建多图层加速渲染，后融合在一起
  - 图层的绘制拆分出绘制指令，按顺序组成绘制列表，提交到合成线程
  - 光栅化（栅格化）生成位图：合成线程将图层划分成图块，并在光栅化线程池中将图块转换成位图
  - 浏览器开始绘制帧渲染到页面上，
