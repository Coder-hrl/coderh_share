---
title: 从输入 URL 到呈现页面过程
---

> 什么是正向代理，什么是反向代理？
> 正向代理对于服务端是透明的，服务器端并不知道真正访问的 ip 地址是谁（如 VPN，各种加速器）
> 反向代码对于客户端是透明的，客户端并不知道真正返回的是哪个服务器返回的（如负载均衡）
>
> ---
>
> 在 http1.1 下，会自动开启长连接

- 输入`url`：用户在地址栏按下回车，先检查输入的是关键字还是复合`url`的规则，如果是是没有 http 等前缀的话，会将其组装成完整的 URL 进行访问
- 检查缓存：首先会检查浏览器的缓存是否可用，如果是强缓存的话，会直接返回资源，如果是`no-cache`的话，会发送请求访问服务器，判断缓存是否新鲜，如果新鲜的话直接返回（注意不要给 html 设置 max-age，这样会很难触发更新）(会根据 html 中生成的`chunkId`来判断，其他资源是否新鲜)
- DNS 解析：如果协商缓存不可用的话，就会进行 DNS 解析，会通过迭代查询和递归查询解析`域名`来得到 ip 地址，会根据浏览器 IP 缓存==》操作系统 Hosts 文件==》本地 DNS 服务器 ==》根 DNS 服务器 ==》顶级 DNS 服务器 ==》 权威 DNS 服务器(使用的是 UDP 协议，在这个过程中，都会去查看该域名在 DNS 服务器中是否有映射，如果有映射会直接返回查询到的 IP)
- 建立 TCP 连接，根据 IP 地址，首先会进行三次握手后去建立 TCP 连接
- 发送 HTTP 请求时，会携带 cookie，和其他请求头等表示去请求 HTTP
- 发送 HTTP 请求中会进行慢启动，拥塞控制，快恢复等发送 http 报文段，会通过累计确认，校验和等手段来确认报文是完整，没有丢失和损坏的
- 负载均衡：服务器端网关收到 HTTP 请求后，可能会有一系列的负载均衡来进行处理，根据各个服务器的权重开始分发请求，通过`反向代理`分配给对应集群的服务器去执行
- 服务器返回响应：会根据请求头的`缓存标识`来判断缓存是否生效和请求头其他标识来按需返回信息，如果缓存生效返回 304 状态码，如果不生效的话，会返回资源和 200 状态码
- 当 HTTP 请求结束之后，会首先去判断是否开启了长连接`(connection:keep-alive)`是否到了超时时间，如果超过之后则通过四次挥手来断开 TCP 连接
- 浏览器会`缓存`响应头中 cache-control 中 max-age 和 no-Cache
  > 浏览器请求响应过程到此为止，开始浏览器渲染和解析
- 浏览器当解析到后缀名为 html 的文件时，从头到下开始解析，在解析过程中会根据`html标签`构成树类型的节点来构建 DOM 树
- 当在解析到 `link rel="stylesheet"` 的时候，会根据 herf 地址去加载 css 文件，同时会根据 css 构建出 CSSOM 树，`注意加载不会阻塞html渲染，解析则会阻塞`
- 当在解析到`script`标签时，注意到遇到不带 async 和 defer 时，不会去进行异步加载，会阻塞 Dom 解析，如果是 defer 情况下会，在 Dom 渲染后才去加载 js
- 构建渲染树，浏览器会根据 Dom 树和 CSSOM 树构建出`render`渲染树,注意在此过程中，一定会发生重绘和回流这两个流程

#### 渲染树只会渲染可见的节点

1. 从 Dom 树的根节点开始白能力每个可见的节点
2. 对于每个可见节点，并找到 CSSOM 树对应规则，并应用他，
3. 根据每个可见节点，以及其对应的样式，组合生成渲染树，
   - 一些不会渲染输出的节点，比如 scripts，meta，link 等
   - 一些通过 css 进行隐藏的节点，比如 display：none，对于其他属性还是会渲染的

#### 回流

- 当浏览器计算节点在设备视口内的确切位置和大小，这个计算的阶段就是回流
- 为了弄清每个节点在网站上的确切位置和大小，浏览器从渲染树的根节点开始遍历
- 回流一定会引发重绘，但是重绘不一定引发回流

1. 删除和添加某个 Dom 元素
2. 元素位置发生改变
3. 元素大小发生改变
4. 页面一开始渲染
5. 浏览器的尺寸变化
6. 内边距和外边距，边框大小，高度和宽度等
7. 内容发生发生变化(这肯定避免不了)

#### 重绘

- 我们通过构造渲染树和回流阶段，我们知道哪些节点是可见的，一级可见节点的样式和具体的几何信息，我们就可以将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段叫做重绘节点

#### 浏览器的优化机制

浏览器是很聪明，因此大多数浏览器通过通过队列修改并执行来优化重绘过程，浏览器会将修改操作放到队列中，一段时间或者超过阈值之后才会清空队列，当时，`当你获取布局信息的操作时，会强制触发队列刷新`,offsetTop,offsetLeft,scrollTop,clientTop，getComputedStyle()等属性的时候

#### 最小化重绘和重排

由于重绘和重排的代价比较大，我们可以减少发生的次数，在一个操作中尽可能多的对 Dom 和样式进行修改

#### 批量修改 Dom

1. 让元素脱离文档流
2. 对其及逆行多次修改
3. 将元素带回到文档中
4. 使用绝对定位让复杂动画脱离文档流减少父元素以及后续元素频繁的回流

#### css3 硬件加速（GPU 加速）

1. 使用 css3 硬件加速，可以让 transform、opacity、filters 这些动画不会引起回流重绘 。

2. 对于动画的其它属性，比如 background-color 这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。

- 布局，根据渲染树将 DOM 中每个节点渲染到屏幕上中的正确位置
- 绘制，根据渲染树，绘制出所有的节点，其中会采用一些方法来加速 CSS 渲染
  - 构建多图层加速渲染，后融合在一起
  - 图层的绘制拆分出绘制指令，按顺序组成绘制列表，提交到合成线程
  - 光栅化（栅格化）生成位图：合成线程将图层划分成图块，并在光栅化线程池中将图块转换成位图
  - 浏览器开始绘制帧渲染到页面上，

# 为什么需要 HTTP 缓存这个东西

> 为了减轻服务器的压力

在 HTTP 请求与响应交互过程中是一个相当耗时且占用资源的过程，而 HTTP 缓存可以存储与请求相关联的响应，并将存储的响应复用于后续请求中，当响应可复用时，源服务器不需要处理请求

- 根据 HTTP 缓存标准，缓存分为`私有缓存`和`共享缓存`
- 私有缓存是绑定到特定客户端的缓存，通常是浏览器缓存，但是存储的响应不与其他客户端共享，因此私有存储可以存储该用户的个性化响应
- 共享缓存是缓存位于客户端和服务器之间，可以存储在用户之间共享的响应，共享缓存还可以进一步细分为代理缓存和托管缓存。
- 托管缓存由服务开发人员明确部署，以降低源服务器负载并有效地交付内容

## 协商缓存和强缓存

- 浏览器在加载资源时，根据请求头的 expires 和 cache-control 判断是否命中强缓存，是则从缓存读取资源，不会发请求到服务器
- 如果过没有命中强缓存，浏览器一定会发送一个请求到服务器，通过 last-modified 和 etag 验证资源是否命中协商缓存，如果命中是不会直接返回这个资源的数据，依然从缓存中读取资源。
- 如果前面两者都没有命中，直接从服务器加载资源

## expires 和 max-age 的区别

- max-age 代表缓存多长的时间，单位是秒，max-age=604800，如果时间小于 max-age 则为 fresh，超过的话就 stale
- Expires 则是通过时间格式的方式存在,expires：sun，28，Feb 2022 22:22:22 GMT，但是因为时间格式难以解析，同时有可能通过故意偏差系统时钟来诱发问题。

## 在默认情况下，强缓存的优先级要比协商缓存高

- 如果浏览器对某个资源的请求没有命中强缓存的话，就会发送一个请求到服务器，验证协商缓存是否命中，返回 HTTP 状态码 304 并返回一个 Not Modified 的字符串

### HTTP2.0

- 二进制分帧：在之前的 HTTP 版本中，我们是通过文本的方式传输数据。在 HTTP/2 中信息和数据体都是二进制，并且统称为"帧"：用头信息帧放头部字段，用数据帧放请求数据体，是一堆乱序的二进制帧，它们不存在先后关系，因此不需要排队等待，是 HTTP2 多路复用的基础。
- 头部压缩 HTTP2 使用 HPACK 算法 压缩头部然后再发送，并在两端维护了索引表，用于记录出现过的 header，后面在传输过程中就可以传输已经记录过的 header 的键名，对端收到数据后就可以通过键名找到对应的值。
- 多路复用 在一个连接里，可以同时发送多个请求或回应，且不用按顺序一一对应，这样子解决了 HTTP 队头阻塞的问题。
- 服务器推送 允许浏览器发送一个请求后，服务器主动向浏览器推送与这个请求相关的资源，这样浏览器就不用发起后续请求去获取一些资源。但是 Chrome106 版本禁用了，改为 103 状态码；

因为 103 传回来的只是一个资源的地址、类型等信息，而不是完整的资源，传输体积很小；具体要不要进行请求实际资源，由客户端自己决定；而 HTTP2 服务器推送是直接推送整个完整资源，传输体积大，会占用不必要的大量带宽；

服务器推送时，客户端的特点：

1. 客户端可以缓存推送的资源
2. 客户端可以拒收推送过来的资源(状态码 103，浏览器控制)
3. 服务器可以按照优先级推送资源

### TCP 和 UDP 特点

- `TCP` 是一个面向连接的传输层协议，是可靠的，基于字节流的。同时还具有`累计确定`,`尾部校验和`,`拥塞控制`,`超时重传`等机制来保证 HTTP 没有丢失报文 基于`字节流`,`首部开销较大`
  - 可靠性指 TCP 具有 `确认应答ACK` 和 `序列号`来实现可靠传输；
  - 仅支持一对一的
  - 慢启动=>拥塞控制=>快速重传=>快速恢复
- `UDP`是一个面向无连接的传输层协议，HTTP3 底层就是由 UDP 实现，无须多余握手过程,基于`数据包`，`首部开销较小`

  - 而 UDP 是基于一对多的

- TCP 基于字节流是指：TCP 是将一条用户信息根据滑动窗口的字节大小，拆分成多个 TCP 报文段（TCP 将数据看作一连串字节流）

### 是什么限制了 GET 方法的 URL 长度

从`HTTP协议规范层面`说，规范没有对`URL`的长度进行限制，是`浏览器、代理服务器的读取`有限制；

### DNS 迭代查询和递归查询 `UDP 查询`

- 递归查询，是指浏览器 DNS 缓存=> 主机 Host 文件=>本地 DNS 解析器缓存 => 本地 DNS 服务器

- 迭代查询，域名服务器返回单次查询的结果。下一级的查询由用户自己请求。使用迭代查询，用户需要发出 多次的查询请求。
  - 根域名服务器，有则返回
  - 顶级域名服务器，有则返回
  - 权威域名服务器，有则返回

所以一般而言，本地 DNS 服务器查询是递归查询，而本地 DNS 服务器向其他域名服务器请求的过程是迭代查询的过程
