# 从输入 URL 到呈现页面过程

> 什么是正向代理，什么是反向代理？
> 正向代理对于服务端是透明的，服务器端并不知道真正访问的 ip 地址是谁（如 VPN，各种加速器）
> 反向代码对于客户端是透明的，客户端并不知道真正返回的是哪个服务器返回的（如负载均衡）
>
> ---
>
> 在 http1.1 下，会自动开启长连接

- 输入`url`：用户在地址栏按下回车，先检查输入的是关键字还是复合`url`的规则，如果是是没有 http 等前缀的话，会将其组装成完整的 URL 进行访问
- 检查缓存：首先会检查浏览器的缓存是否可用，如果是强缓存的话，会直接返回资源，如果是`no-cache`的话，会发送请求访问服务器，判断缓存是否新鲜，如果新鲜的话直接返回（注意不要给 html 设置 max-age，这样会很难触发更新）(会根据 html 中生成的`chunkId`来判断，其他资源是否新鲜)
- DNS 解析：如果协商缓存不可用的话，就会进行 DNS 解析，会通过迭代查询和递归查询解析`域名`来得到 ip 地址，会根据浏览器 IP 缓存==》操作系统 Hosts 文件==》本地 DNS 服务器 ==》根 DNS 服务器 ==》顶级 DNS 服务器 ==》 权威 DNS 服务器(使用的是 UDP 协议，在这个过程中，都会去查看该域名在 DNS 服务器中是否有映射，如果有映射会直接返回查询到的 IP)
- 建立 TCP 连接，根据 IP 地址，首先会进行三次握手后去建立 TCP 连接
- 发送 HTTP 请求时，会携带 cookie，和其他请求头等表示去请求 HTTP
- 发送 HTTP 请求中会进行慢启动，拥塞控制，快恢复等发送 http 报文段，会通过累计确认，校验和等手段来确认报文是完整，没有丢失和损坏的
- 负载均衡：服务器端网关收到 HTTP 请求后，可能会有一系列的负载均衡来进行处理，根据各个服务器的权重开始分发请求，通过`反向代理`分配给对应集群的服务器去执行
- 服务器返回响应：会根据请求头的`缓存标识`来判断缓存是否生效和请求头其他标识来按需返回信息，如果缓存生效返回 304 状态码，如果不生效的话，会返回资源和 200 状态码
- 当 HTTP 请求结束之后，会首先去判断是否开启了长连接`(connection:keep-alive)`是否到了超时时间，如果超过之后则通过四次挥手来断开 TCP 连接
- 浏览器会`缓存`响应头中 cache-control 中 max-age 和 no-Cache
  > 浏览器请求响应过程到此为止，开始浏览器渲染和解析
- 浏览器当解析到后缀名为 html 的文件时，从头到下开始解析，在解析过程中会根据`html标签`构成树类型的节点来构建 DOM 树
- 当在解析到 `link rel="stylesheet"` 的时候，会根据 herf 地址去加载 css 文件，同时会根据 css 构建出 CSSOM 树，`注意加载不会阻塞html渲染，解析则会阻塞`
- 当在解析到`script`标签时，注意到遇到不带 async 和 defer 时，不会去进行异步加载，会阻塞 Dom 解析，如果是 defer 情况下会，在 Dom 渲染后才去加载 js
- 构建渲染树，浏览器会根据 Dom 树和 CSSOM 树构建出`render`渲染树,注意在此过程中，一定会发生重绘和回流这两个流程
- 布局，根据渲染树将 DOM 中每个节点渲染到屏幕上中的正确位置
- 绘制，根据渲染树，绘制出所有的节点，其中会采用一些方法来加速 CSS 渲染
  - 构建多图层加速渲染，后融合在一起
  - 图层的绘制拆分出绘制指令，按顺序组成绘制列表，提交到合成线程
  - 光栅化（栅格化）生成位图：合成线程将图层划分成图块，并在光栅化线程池中将图块转换成位图
  - 浏览器开始绘制帧渲染到页面上，

# 为什么需要 HTTP 缓存这个东西

> 为了减轻服务器的压力

在 HTTP 请求与响应交互过程中是一个相当耗时且占用资源的过程，而 HTTP 缓存可以存储与请求相关联的响应，并将存储的响应复用于后续请求中，当响应可复用时，源服务器不需要处理请求

- 根据 HTTP 缓存标准，缓存分为`私有缓存`和`共享缓存`
- 私有缓存是绑定到特定客户端的缓存，通常是浏览器缓存，但是存储的响应不与其他客户端共享，因此私有存储可以存储该用户的个性化响应
- 共享缓存是缓存位于客户端和服务器之间，可以存储在用户之间共享的响应，共享缓存还可以进一步细分为代理缓存和托管缓存。
- 托管缓存由服务开发人员明确部署，以降低源服务器负载并有效地交付内容

## 协商缓存和强缓存

- 浏览器在加载资源时，根据请求头的 expires 和 cache-control 判断是否命中强缓存，是则从缓存读取资源，不会发请求到服务器
- 如果过没有命中强缓存，浏览器一定会发送一个请求到服务器，通过 last-modified 和 etag 验证资源是否命中协商缓存，如果命中是不会直接返回这个资源的数据，依然从缓存中读取资源。
- 如果前面两者都没有命中，直接从服务器加载资源

## expires 和 max-age 的区别

- max-age 代表缓存多长的时间，单位是秒，max-age=604800，如果时间小于 max-age 则为 fresh，超过的话就 stale
- Expires 则是通过时间格式的方式存在,expires：sun，28，Feb 2022 22:22:22 GMT，但是因为时间格式难以解析，同时有可能通过故意偏差系统时钟来诱发问题。

## 在默认情况下，强缓存的优先级要比协商缓存高

- 如果浏览器对某个资源的请求没有命中强缓存的话，就会发送一个请求到服务器，验证协商缓存是否命中，返回 HTTP 状态码 304 并返回一个 Not Modified 的字符串
