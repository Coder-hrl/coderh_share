---
title: 日常工作总结
---

1， Form.Item 中只能有一个子元素，否则会回显失败,从而不显示表单，主要是不报错!
2，使用[...items,...goods]来合并数组
3， 有时候,对于一串数据,个别不一样,使用一个函数动态的修改返回数据的方式比复制粘贴很多次更有用!
4， 对于隐式转换来说,应该更加的保证规范性,我推荐使用整数类型 ParseInt,浮动类型 ParseFloat 来进行转换,更为正规一些
5，对于所有的数组列表,我不建议直接使用 item 来代替遍历值,不仅没有语义性,反而在下面遍历时,难以看懂,我建议在起所有的数组列表时都以复数的形式存在,在 map 时使用单数来进行展示(如 movies,以 movie 为 item)
6， 对于函数内的变量来说,我建议使用\_来表示这个变量是私有变量
7， 对于 className 绑定,有以下的三种方式.

1. 相对于 Vue 中的三元绑定,在 React 可以使用模板字符串中来动态添加,更加的方便一些,或者使用+的方式来进行拼接使用,
2. 使用数组的方式来绑定,注意最后要 join" "的方式来转换为 class
3. 使用 classnames 第三方库的方式来使用动态绑定
   8，详解数组方法 sort，当返回值为负数时，为倒序，当返回值为正数时，开正序
   const list =[1,2,3,4,5,6,7,8,9]
   function(list){
   // 因为
   list.sort(Math.random()-0.5)
   }
   9，useEffect 中最重要的 dependence 是可以监听到 obj 对象中属性的变化
   10，数组方法 reduce 方法，第二个参数是初始值，如果不传的话，就是没有初始值，直接以第一个值为初始值
   const total = list.reduce(
     (pre, cur) => {
       return pre \* cur;
     },
   );
   11，token 是放到哪里的，是放到 cookie 中的，这个在发送请求中会自动携带 token 来发送请求
   12，React 是声明式，组件化，一次更改全平台适用，React 必须要像纯函数那样，保护 props 的不可修改特性，同时事件必须采用小驼峰的方式才可以添加
   13，当三元表达式超过三层时，我们应该按情况使用 includes，ifelse Switch case 或者对象方法等来进行重构，因为三元超过三层后会很大程度上降低阅读体验
   14, 在 React18 前,在 setTimeout 中两次 setState 是同步的,意味着会 render 两次,但是在 React18 之后,会把 setState 进行合并合并后进行渲染,flushsync 会进行批处理方式
   15, 同层节点对比,不进行跨层对比 不同类型,生成的树也将变的完全不一样,指定 key 来保证最小范围修改
   16, 对于 useState 的新玩法，const [obj,setObj] = useState({a:13}),其中的 setObj(preValue=>{return {...preValue,newValue}}) 其中的 prevalue 是之前的值
   17，自定义 hook 本质上其实也还是逻辑代码的复用，有入参，也必须有返回值
   ● 名字应该始终以 use 开头。
   ● 在自定义 Hook 中调用其他 Hook。
   18, const num = 123,num.length 为 undefined 这是因为在调用 length 方法的时候使用了包装类型
   19，如何让 a==1&a==2&a==3 如果相等，改为全等又如何使用呢
4. 取巧的方法，添加空白字符，假装以为是 a 其实可能是 a 空 或者 空 a
5. 使用隐式转换
   const a ={
   i: 1,
   // valueOf 替换成 toString 效果是一样的
   // toString
   valueOf() {
   return this.i++;
   },
   }
   //因为在对数组使用等于时，会调用 join 方法 我们可以使用重写方法来实现
6. 使用数据劫持的方法
   let \_a = 1
   Object.defineProperty(window,"a",{
   get(){
   return \_a++
   }
   })
   let a = new Proxy({ i: 1 }, {
   get(target) {
   return () => target.i++
   }
   })

if (a == 1 && a == 2 && a == 3) {
console.log('前端胖头鱼') // 前端胖头鱼
}
20，如何将字符串转换为对象中的字段名
// 需求传过来的是字符串，但是字符串却是 obj 中的字段名
const obj = {}
obj["abc"] = 123
console.log(obj) // {abc:123}
// 为了解决这种问题
const obj2 = {}
let obj3
obj3 = { ...obj2 , abc:123 }
// 同时也是为了解决
obj3.abc // 这种问题
21，焦点聚集子元素，改变父元素样式
focus-within 伪类选择器，它表示一个元素获得焦点或该元素的后代元素获得焦点
.parent:focus-within {
//修改父元素样式
color: red;
}
22，为什么要进行三次握手和四次挥手
三次握手
要确认 TCP 的可靠传输能力，既然是可靠的传输，就要确认双方的发送和接收能力是正常的

1. 第一次握手，确认客户端的发送能力
2. 第二次握手，确认服务端的发送能力和接收能力
3. 第三次握手，确认客户端的接收能力
   四次挥手
   既然要断开请求，就要保证客户端不再发送请求，同时服务端已经完成了响应信息的发送
4. 第一次挥手，客户端告知服务器，客户端不再发送请求，但并未确定，处于待关闭状态
5. 第二次挥手，服务端收到请求，进入 CLOSED_WAIT 状态，发送最后的响应。
6. 第三次挥手，服务端告知客户端，响应信息已完成发送，服务端处于待关闭状态
7. 第四次挥手，客户端收到服务端的信息，关闭通道，同时告知服务端，服务端也关闭通道
   23，相对定位 relative
   相对定位中（position 为 relative），盒的偏移位置由 top，right，bottom，left 定义， 即使有偏移，仍然保留原有的位置，其它普通流不能占用这个位置
   24, 构造函数，不仅仅是一个对象，同时也是一个函数
   function Foo(){}
   Foo 的 prototype 是 Foo.prototype
   Foo.prototype 是 Foo 的 constructor
   实例对象的**proto**是 Foo.prototype
   函数对象也是有自己的**proto**的，是 Function.prototype
   25, 为什么 0.1+0.2！==0.3
   本质是二进制模拟十进制进行计算时混乱
   因为 JS 所使用的是 IEEE-754 标准来计算， 通过 64 位来表示一个数字
   0.1 和 0.2 转换成二进制后会无限循环
   精度损失可能出现在进制转化和对阶运算过程中
   4.4 三种刷新操作对 http 缓存的影响
   ● 正常操作：地址栏输入 url，跳转链接，前进后退等。
   ● 手动刷新：f5，点击刷新按钮，右键菜单刷新。
   ● 强制刷新：ctrl + f5，shift+command+r。
   正常操作：强制缓存有效，协商缓存有效。手动刷新：强制缓存失效，协商缓存有效。强制刷新：强制缓存失效，协商缓存失效。
