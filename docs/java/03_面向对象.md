---
title: 面向对象思想和对象
---

### 面向对象思想

一系列对象合在一起,然后实现功能,有点**类似于电脑坏了,找维修师等思想**

#### 类和对象

> 在java中创建对象,必须要有类的存在
>
> **类是一组相关属性和行为的集合**,我们可以理解为一张**对象的设计图**
>
> 有点类似于设计图和蓝图,**手机和建筑**是设计图实现的对象
>
> 就比如一个手机设计图可以设计出无限个手机

类的本质其实就是对事物的描述

行为:在代码中使用成员方法,需要将static关键字去掉

**com.itheima.test.Student@36baf30c**

`包名称外加文件名`

#### 对象内存图

>  每一个创建出来的对象都会独自占有一个内存,相互独立,互不打扰的

对于引用数据类型的比较都是比较引用内存地址的

#### 成员变量和局部变量

定义的位置,定义在方法外是**成员变量**,定义在方法中则是**局部变量**

成员变量**保存在堆中**,局部变量**则是保存在栈中**

成员变量对象的**变量的创建而存在**,局部变量则是**随着方法的运行结束**

在Java中,**如果一个变量没有被引用使用,就会被垃圾回收处理掉**

变量的使用范围,是在**括号内部中使用**

#### this关键字

this可以访问到类中的方法和属性

当**形参的变量名**和**类中的变量进行重名的时候**

this保证了只是获取到类中的变量,与Js不同的是,在Js中必须要使用this

与JS完全一致,this的使用方法,谁调用指向谁

#### 构造方法

1. 方法名与类名相同,大小写也要一致
2. 没有返回值类型,连void都没有
3. 没有具体的返回值(不能由return语句带回结果数据)
4. 在创建对象的时候执行,每创建一次对象,就会执行一次构造方法

```java
public class Student {
  public Student(String name,int age){
    this.name = name;
    this.age = age
  }
}
```

**不可以手动去调用构造方法**

#### 封装

> 封装的设计规范 **合理隐藏,合理暴露**
>
> 实现的细节进行封装,将调用的参数暴露出来
>
> 将内部使用的参数,不想被访问的使用private修饰
>
> 实现可插拔的方式

私有成员变量(为了保证数据的安全性)

针对私有的成员变量,提供了**对应的set和get方法**

### 权限修饰符

public 公共的,可继承的

private 私有的,同一个类中

protect 受保护的,可继承的

default  同一个类中,同一个包中使用

### API使用流程

1. 索引位置搜索自己要查看的类
2. 看包,是不是java.lang核心包   不是java.lang需要引入
3. 这个类的介绍 搞清楚类的作用
4. 查看这个类的构造方法
5. 这个类的成员方法
   1. 方法名
   2. 参数
   3. 返回值
   4. 介绍

### String 类

1. Java程序中所有双引号字符串,都是String这个类的对象,可以调用字符串方法
2. 字符串一旦被创建,就不可修改,字符串内容不可改变,**如果想要改变的话,只能使用新的对象作为替换**

对于String来说,两个相同的字符串,是相等的

```java
String s = "asd";
String s1 ="asd";
System.print.out(s==s1) //true
```

字符串常量池,当我们使用双引号创建字符串对象时,会检查常量池中是否存在该数据 `(String Table)`String常量池,**在JDK7之后,放到内存中**

**不存在则创建,存在则复用**

推荐使用**双引号直接创建,通过构造方法创建**

但是使用`String s = new String()`,创建的则是在堆内存中创建了新的内存空间,如果`StringTable`中存在的话则会**从字符串常量池中拷贝一份地址**

一个在**堆内存中**,另外一个则是在**字符串常量池**中

```java
String s1 = "abc"
String s2 = "ab"
String s3 = s2 + "c"
  s1==s3 //false
```

字符串的拼接,底层使用的是Stringbuilder以及append实现的,然后**调用toString方法做类型转换**,然后**保存toString之后的内存地址**

#### Java中常量优化机制

```java
String s1 = "abc"
String s2 = "a"+"b"+"c"
```

在进行编译的时候,会有一个常量优化机制

#### boolean equals(Object)

**将字符串与指定的对象进行对比**

**equalsIgnoreCase** 将此字符串与另外一个String进行对比,不考虑大小写

toCharArray() 将字符串转换为字符数组

substring(number) 索引从0到number的返回一个新的String 

### String builder

是一个可变字符序列,如果可能,建议优先使用此类,在大多数实现中,他比SringBuilder要快

可以理解为一个容器,可以**存储任意数据类型,只要进入该容器,都会变成字符串**

### 集合  ArrayList快速入门

**使用ArrayList list = new ArrayList()**

打印对象名,都没有看到地址值,而是元素内容

1. 集合容器的创建细节
   - 可以添加任意类型数据
   - 但是数据不够严谨,类似于js中的array
   - 需要使用`ArrayList<String> a = new <>ArrayList;`
   - 不允许编写基本数据类型,在js中String是基本数据类型
   - Int Integer  char  Character 其他都是大写
   - 泛型是不允许进行强制转换的
2. ArrayList增删改查
   - add`E` 添加
   - remove`(index)` 删除  返回被删除的元素
   - set`(index,element)` 修改
   - get`(index)` 返回index的元素值
   - lastIndexOf 返回所查数组的index值