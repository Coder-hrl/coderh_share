---
title: 面向对象思想和对象
---

## 面向对象思想

一系列对象合在一起,然后实现功能,有点**类似于电脑坏了,找维修师等思想**

#### 类和对象

> 在 java 中创建对象,必须要有类的存在
>
> **类是一组相关属性和行为的集合**,我们可以理解为一张**对象的设计图**
>
> 有点类似于设计图和蓝图,**手机和建筑**是设计图实现的对象
>
> 就比如一个手机设计图可以设计出无限个手机

类的本质其实就是对事物的描述

行为:在代码中使用成员方法,需要将 static 关键字去掉

**com.itheima.test.Student@36baf30c**

`包名称外加文件名`

#### 对象内存图

> 每一个创建出来的对象都会独自占有一个内存,相互独立,互不打扰的

对于引用数据类型的比较都是比较引用内存地址的

#### 成员变量和局部变量

定义的位置,定义在方法外是**成员变量**,定义在方法中则是**局部变量**

成员变量**保存在堆中**,局部变量**则是保存在栈中**

成员变量对象的**变量的创建而存在**,局部变量则是**随着方法的运行结束**

在 Java 中,**如果一个变量没有被引用使用,就会被垃圾回收处理掉**

变量的使用范围,是在**括号内部中使用**

#### this 关键字

this 可以访问到类中的方法和属性

当**形参的变量名**和**类中的变量进行重名的时候**

this 保证了只是获取到类中的变量,与 Js 不同的是,在 Js 中必须要使用 this

与 JS 完全一致,this 的使用方法,谁调用指向谁

#### 构造方法

1. 方法名与类名相同,大小写也要一致
2. 没有返回值类型,连 void 都没有
3. 没有具体的返回值(不能由 return 语句带回结果数据)
4. 在创建对象的时候执行,每创建一次对象,就会执行一次构造方法

```java
public class Student {
  public Student(String name,int age){
    this.name = name;
    this.age = age
  }
}
```

**不可以手动去调用构造方法**

#### 封装

> 封装的设计规范 **合理隐藏,合理暴露**
>
> 实现的细节进行封装,将调用的参数暴露出来
>
> 将内部使用的参数,不想被访问的使用 private 修饰
>
> 实现可插拔的方式

私有成员变量(为了保证数据的安全性)

针对私有的成员变量,提供了**对应的 set 和 get 方法**

### 权限修饰符

public 公共的,可继承的

private 私有的,同一个类中

protect 受保护的,可继承的

default 同一个类中,同一个包中使用

### API 使用流程

1. 索引位置搜索自己要查看的类
2. 看包,是不是 java.lang 核心包 不是 java.lang 需要引入
3. 这个类的介绍 搞清楚类的作用
4. 查看这个类的构造方法
5. 这个类的成员方法
   1. 方法名
   2. 参数
   3. 返回值
   4. 介绍

### String 类

1. Java 程序中所有双引号字符串,都是 String 这个类的对象,可以调用字符串方法
2. 字符串一旦被创建,就不可修改,字符串内容不可改变,**如果想要改变的话,只能使用新的对象作为替换**

对于 String 来说,两个相同的字符串,是相等的

```java
String s = "asd";
String s1 ="asd";
System.print.out(s==s1) //true
```

字符串常量池,当我们使用双引号创建字符串对象时,会检查常量池中是否存在该数据 `(String Table)`String 常量池,**在 JDK7 之后,放到内存中**

**不存在则创建,存在则复用**

推荐使用**双引号直接创建,通过构造方法创建**

但是使用`String s = new String()`,创建的则是在堆内存中创建了新的内存空间,如果`StringTable`中存在的话则会**从字符串常量池中拷贝一份地址**

一个在**堆内存中**,另外一个则是在**字符串常量池**中

```java
String s1 = "abc"
String s2 = "ab"
String s3 = s2 + "c"
  s1==s3 //false
```

字符串的拼接,底层使用的是 Stringbuilder 以及 append 实现的,然后**调用 toString 方法做类型转换**,然后**保存 toString 之后的内存地址**

#### Java 中常量优化机制

```java
String s1 = "abc"
String s2 = "a"+"b"+"c"
```

在进行编译的时候,会有一个常量优化机制

#### boolean equals(Object)

**将字符串与指定的对象进行对比**

**equalsIgnoreCase** 将此字符串与另外一个 String 进行对比,不考虑大小写

toCharArray() 将字符串转换为字符数组

substring(number) 索引从 0 到 number 的返回一个新的 String

### String builder

是一个可变字符序列,如果可能,建议优先使用此类,在大多数实现中,他比 SringBuilder 要快

可以理解为一个容器,可以**存储任意数据类型,只要进入该容器,都会变成字符串**

### 集合 ArrayList 快速入门

**使用 ArrayList list = new ArrayList()**

打印对象名,都没有看到地址值,而是元素内容

1. 集合容器的创建细节
   - 可以添加任意类型数据
   - 但是数据不够严谨,类似于 js 中的 array
   - 需要使用`ArrayList<String> a = new <>ArrayList;`
   - 不允许编写基本数据类型,在 js 中 String 是基本数据类型
   - Int Integer char Character 其他都是大写
   - 泛型是不允许进行强制转换的
2. ArrayList 增删改查
   - add`E` 添加
   - remove`(index)` 删除 返回被删除的元素
   - set`(index,element)` 修改
   - get`(index)` 返回 index 的元素值
   - lastIndexOf 返回所查数组的 index 值

## 面向对象高级

### 面向对象高级

static 是静态的意思,可以修饰成员变量和成员方法

1. 被所有对象所共享
2. 多一种调用方式,使用类名称
3. 随着类的加载而加载,优先于对象存在,可以在创建对象之前存在

**是否需要被所有对象进行共享,需要使用类去拿里面的变量**

**编写成员方法**

**编写工具类,不声明对象,只是用来处理数据**

#### 注意事项

在`静态方法`中,**可以直接访问静态成员(直接访问)**

同时不可以使用 this 关键字

#### 继承

> 能够提高代码的可复用性,适用于总体架构设计
>
> **类与类之间产生了 is a 的关系,就可以考虑使用继承,来优化代码**

让类与类之间产生关系,子类可以使用父类中非私有的成员

**如果一个 java 文件中可以编写多个 class**,只能有一个 class 被 public 修饰

如果父与子是一个相同的变量,我们要使用父类的方法的时候,我们可以使用 super.来取到父类的值

#### 方法重载和方法重写

方法重载(Overload):

1. 在同一个类中,方法名相同,参数不同,与返回值无关
2. 参数不同,类型不用,个数不同,顺序不同

方法重写(Override):

1. 在子父类中,出现了与父类声明一样的方法
2. 子类方法对父类方法进行重写

如果**参数相同**,**声明名称相同**则是方法重写;

如果声明名称相同,但是参数不相同则是重载;

##### 注意事项

父类中私有类方法不可以被重写

子类重写父类时,子类的权限要大于等于父类权限

#### 权限修饰符

| 权限修饰符 | 同一个类 | 同一个包 | 不同包的子类 | 不同包的无关类 |
| ---------- | -------- | -------- | ------------ | -------------- |
| private    | ✅       |          |              |                |
| default    | ✅       | ✅       |              |                |
| protected  | ✅       | ✅       | ✅           |                |
| public     | ✅       | ✅       | ✅           | ✅             |

**Java 只支持单继承,并不支持多继承,但是支持多层继承**

继承中的成员访问特点 -构造方法

子类在初始化之前,是否需要先完成父类的继承

**在所有的构造方法中,都会默认添加一个 super()这个方法来访问上层方法**

会先去执行父类的执行构造方法

**Java 中所有的类(除了 Object 类),都会直接或者间接继承到了 Object 类中,很多方法都是继承自 Java 中的 Object 类中**

#### private

私有属性是可以继承到的,不过只是无法去访问,因为权限不够

存在空参构造和带参构造

#### 扩展关闭原则

**对扩展功能进行开放,对修改代码做关闭**

使用**this(a,b,c)可以调用本类中的构造方法**

**this()**和**super()**都会去争夺构造方法第一行的位置,两者是不能共存

#### final 关键字

> 命名规范: 如果变量是一个单词的话,所有字母大写 max MAX
>
> 如果变量名是多个单词的话,所有字母大写,中间使用下划线进行分割 bigmax BIG_MAX

修饰方法: 表明此方法是最终方法,不能被重写

修饰类: 表示此类为最终类,不能被继承

修饰变量: 表明该变量是常量,不能再次被赋值 **如果你有数据是不想被再次赋值**

final 修饰引用变量 **修饰的是地址值不允许修改**

对于变量的修饰是与 Js 中的 const 非常相似的

成员变量的注意事项

1. final 在修饰成员变量,不允许修饰默认值
2. 在定义的时候直接赋值,声明之后的常量不允许再次修改的

#### 包

使用package关键字,包的本质其实就是文件夹,用于管理类文件

我们**可以自动导入包**,可以导入不同包中的类

使用全类名的方式去创建一个对象

#### 抽象

> **抽象方法必须要存储在抽象类中的**

抽象类是一种特殊的父类 abstract  class

抽象类自身是没有方法的实现的,**所有的子类必须要实现父类的抽象方法**

必须要使用public abstract void say() 抽象方法

如果抽象出一个对象,子类分别共有一个方法,父类无法描述这个方法

就可以使用abstract来抽象这个方法

**注意事项**

1. 抽象类是不可以被实例化操作的,只有继承抽象类的类才可以被实例化
2. 抽象类是可以实现抽象方法的,子类可以使用super来进行访问
3. 是可以编写普通方法的,可以让子类继承使用

冲突调用

-  final 抽象方法是必须要子类重写,而final则不允许子类重写
- static 可以被类名调用,类名调用抽象方法没有意义
- private 被private修饰的,代表是不可被访问的,因为权限问题,所以没有意义

#### 接口

> 接口同样代表着制定规则   使用interface来修饰符
>
> 抽象类也同样代表着声明规则,更多体现的是行为的抽象

**如果发现一个类所有的组成都是抽象方法,没有成员方法**这种类,我们通常会设计为Java中的接口,因为这个类的唯一价值,就是声明规则

```java
interface Coder {
    void method();
    void show();
}

// 实现了接口的类称之为实现类
class A implements Coder {
    @Override
    public void method() {
        
    }

    @Override
    public void show() {

    }
}
```

我们可以使用`implements`这个关键字来实现接口,同时这个类会被称之为实现类

抽象类,同时也可以实现接口,抽象类会继承接口的实现类

**接口成员的特点**

1. 接口中**没有构造方法**
2. 成员变量,只能定义常量 会**自动添加 public static final**三个关键字

一个类是**可以实现多个接口的**

**抽象接口一般是对方法(行为)的抽象**

**抽象类一般是对事物(对象)的抽象**

写业务之前,应该先要编写业务接口,然后再编写类**实现里面的接口**

#### 多态

不同的对象,同样的方法,不一样的展示方式

我们可以使用抽象类的类型,来描述一个子类对象

```java
public class interfaceDemo2 {
    public static void main(String[] args) {
        A1 a = new Dog();
        A1 b = new Cat();
    }
}

abstract class A1 {
    public abstract void say();
}

class Dog extends A1 {
    @Override
    public void say() {

    }
}

class Cat extends A1 {
    @Override
    public void say() {

    }
}
```

**多态**

1. 对象多态
   - 父类引用指向子类对象,可以让父类类型代表子类类型
   - 把方法的形式参数定义为父类类型,这个方法就可以接受到该父类的任意子类对象了
2. 行为对象
   - 相同的方法,不一样的对象展示不同的行为,或形态的能力

**多态的访问特点**

编译看左边(父类),运行看右边(子类)

因为编译时要先查看父类中是否有这个方法

因为担心调用的方法是父类的抽象方法

**多态的坏处和弊端**

好处:提高了代码的可扩展性

坏处:不能调用子类的特有的成员方法(这个是指两个子类没有一个相同的方法)

- 向上转型 从子到父(父类引用指向子类对象)
- 向下转型  从父类重新指向之类对象

**实际类型和目标类型**不匹配,就会出现异常,可以使用**类型缩小**来判断

**instanceof** 判断左边的引用是否是右边类型,非常像Javascript中的**instanceof**方法

接口中也是可以填写默认方法(**default进行修饰**)的,就是为了防止所有的实现类都需要重写

1. 允许**定义非抽象方法**,不过需要加入**default关键字**
2. public key省略,但是**default是不可以省略**的  `JDK8`
3. 可以**调用私有方法**  接口静态方法需要重复使用一个函数,但是**不允许实现类继承 **  `JDK9`
   - 这时就可以使用私有方法,**私有方法的出现本质上**其实还是减少代码量,提高复用性
4. 默认方法,实现类是允许重写的,但是需要去掉default关键字
5. 如果实现了多个接口,多个接口中存在相同的默认方法,可以使用deafult在接口中添加
6. 静态的方法和属性,直接使用类名调用会更好一点

#### 代码块

1. 局部代码块(很少使用)
   - **限定变量的生命周期,提早的释放内存**
2. 构造代码块(很少使用)
   - 在类中直接使用{},是在**创建对象,执行构造方法的时候执行的**
3. 静态代码块
   - 随着类的加载而加载,需要在`static {}`包裹,因为**静态方法随着类的加载而执行,类只加载一次**

#### 内部类(了解)

> 内部类就是在类中继续再编写一个类,内部类可以**调用外部类的方法和属性**
>
> 外部类使用**内部类的方法和细节,需要创建对象访问**才可以

```java
Outer.Inner in = new Outer().new Inner() //使用这种声明方法进行声明变量
  
  class Outer {
    String age = 18;
    public void say(){}
    Ineer i = new Inner();
    i.In()
    class Inner {
      String  name = "libai";
      say();
      public void In(){}
    }
  }
```

2. 静态内部类

由 **static修饰的成员内部类**,静态内部类其实与静态方法类似,静态只能访问静态

静态内部类只能直接访问静态方法,如果访问不是静态的,需要创建变量

2. 局部内部类
3. 匿名内部类  使用 new 接口{ 但是内部要实现接口的方法 } **不需要重新去声明一个类**
   - 如果**抽象实现方法不太多的时候使用**,如果**抽象方法非常多的话,使用内部类**

#### Lambda概述

> 是JDK8之后出现的一种新语法形式
>
> 作用:简化匿名内部类的代码写法
>
> 表达式为`()->{}`,有点像箭头函数的操作流程
>
> lambda只支持函数式编程,也就是只有一个抽象方法

#### 创建窗体

> 使用JFrame类来创建一个窗体
>
> 使用setSize放置宽和高
>
> 使用setVisible来创建现隐方式
>
> 使用setDefaultCloseOperation来显示是否展示关闭

如果**手动取消getLayout默认布局**之后,我们需要**手动的指定组件的摆放位置**

创建**setBounds方法来**设置摆放位置,最后再添加到父元素里面

使用JButton来创建一个按钮,使用JLabel来创建文本和图片样式

**JLabel会默认放到创建的块中居中**,JLabel在设置setBounds设置位置的时候

如果多个组件放到一个位置,如果重叠,后面的图片会被压到新图片下面

使用new ImageIcon来创建一个图片,然后被添加到JLabel中

**使用事件监听的方案**

1. 有两种,一种为ActionListener,使用的是**动作监听**   (**鼠标点击和空格点击**)
   - 需要在参数中创建一个new ActionListener事件来进行处理
2. KeyListener  **使用的是键盘监听的方式**

#### Object方法

`Object.toString()`会返回Object对象的地址,**默认打印对象名返回的不是内存地址**

其实返回的是地址外加哈希算法,算出来的整数(哈希值)

如果你想通过打印对象名,展示的不是对象地址而是具体的值的时候,我们**就可以重写toString方法**

`Object.equals()`默认比较的是对象的地址,我们通常会重写equals方法,让他去比较对象中的内容,而不是对象的地址 **相同返回true,不相同返回false**

== 号对比的**其实是地址,而不是值**

```java
Student stu1 = new Student(name,age);
Student stu2 = new Student(name,age)
  stu1.equals(stu2)  // 就会进行比较
```

向下转型是为了**调用子类特有的成员**



### API 异常

### 集合

### IO

### 多线程

### 网络编程

### 基础加强
