---
title: Java多线程
---

### 相关多线程概念的理解

- 程序:为满足特定的任务,用某种语言编写的**一组指令的集合**,指一段**静态的代码**
- 进程:程序的一次执行过程,或是正在内存中运行的应用程序
  - 每个进程都有独立的空间创建=>运行=>消亡的整个过程(进程的一生)
  - 程序是静态的,进程是动态的
  - 进程是操作系统调度和**分配资源**的**最小单位**,会为每个进程分配不同的内存区域
  - 不同的进程是**不共享内存的**,**进程间的数据交换和通信成本非常高**
- 线程:进程细分为线,一个进程有多个线程,线程是调度的最小单位
  - 一个进程中最少有一个线程,是任务分配的最小单位
  - 一个进程可以**并行运行多个线程**
  - 多个线程可以访问相同的内存单元,使得线程间的通信**更简便和高效**
- 多线程的优点
  - 速度会非常快,**提高CPU利用率**,提高应用程序的响应,可**提高用户体验**
  - 改善程序结构,将长复杂的进程**划分为多个进程**,独立运行,利于理解和修改
- 单核CPU和多核CPU
  - 提高系统性能,提升CPU性能增加多核CPU使用
  - 多个核心的其他公用资源限制
  - 多核CPU之间的协调管理损耗
- 并行(parrallel)和并发(concurrency)
  - 并行,在同一时刻多个事件一起运行,同时发生,多个指令在多个CPU上执行,**在微观上也是并行发生**,并行程序越多,越能大大的提高电脑运行的效率
  - 并发,多个事件在同一个事件段内执行,在**CPU上快速的轮换和交替执行**,在**宏观上认为是多个进程同时发生**  促进系统的整体利用率

### 多线程的创建方式

线程的执行顺序和时机是**不确定的**,按照一种不可预知的方向去运行

```java
Thread l1 = new Thread()
// 重写Thread中的run方法
// 创建当前Thread类的对象
// 调用start方法
// 继承Thread类,重新run方法
 class PrinterNumer extends Thread {
     @Override
      public void run() {
        //重新run方法
          for (int i = 0; i < 100; i++) {
                    System.out.println(i);
                }
                super.run();
            }
        }
PrinterNumer t1 = new PrinterNumer();
// 启动线程   只有运行到start的时候才会开启另外一个线程
// 不能让已经start的线程再次调用start的线程
t1.start();
// t1.run() 如果只调用run的话,它还是只会调用主线程

// 匿名创建类
new Thread() {
     public void run() {
           for (int i = 0; i < 200; i++) {
               System.out.println("匿名thread" + i);
           }
       }
   }.start();

```

实现runnable接口的类型

当一个类直接实现了Runnable类之后,可以直接传入Thread 的实例中

- 创建一个实现Runnable类的方法
- 内部实现run方法,于是会将构造器中run方法传进来

```java
Thread t1 = new Thread(p) // p为实例
//  同时p为实例,相当与一个数据,可以重复使用
```

一个是类继承的方式,另外一种是接口的实现.

建议使用Runnable的的接口实现方式 (实现的Runnable可以当做一个资源来看)

1. 实现方式,避免了单继承的局限性
2. 更适合处理有共享数据的问题
3. 同时实现了数据和代码的分离,让数据单纯的以一种资源存在

对象的start方法都是调用的Thread类中的run方法

### Thread常用的方法

1. Thread的构造器

- public Thread 分配一个新线程对象
- public Runnable类  实现runnable对象的run方法
- public name    给线程添加姓名
- public Runnable 和name   分配一个带有制定目标的新的线程对象并指定名字

2. Thread的方法

- **run**   线程要执行的操作
- **start**    线程执行
- **currentThread**   拿到当前的线程
- **getName**  获得线程名
- **sleep**(long millis)  可以让当前线程睡眠指定的毫秒数
- **yield**()   一旦执行,释放CPU的执行权
- **join**() :在线程A中调用线程b的join方法,意味着线程a进入阻塞状态,知道线程b全部执行完毕才会执行A
- **isAlive**:判断当前线程是否还存活
- **stop** 强行结束一个线程的执行(弃用) suspend  resume 回复线程(弃用)

3. 线程调度的策略  (优先级高的可能会比优先级低的更早执行,是抢占式执行)

- **getPriority()** 获取当前的优先级 默认优先级为5
- **setPriority()** 设置当前线程的优先级   Thread.MAX_PRIORITY 最大线程优先级  范围从[1-10]

4. 多线程的声明周期

- **新建**   new一个线程状态  
- **就绪**   start方法调用之后 进入就绪状态
- **运行**   开始抢占执行,如果失去执行权yield**让权** 重新进去就绪态  只能从就绪态进入运行态
- **死亡**  执行完毕后进入销毁状态,出现未处理的异常,手动调用stop方法
- **阻塞**  sleep,join,失去同步锁,wait,suspend之后会进入阻塞状态,sleep时间结束之后,会重新进入就绪状态
  - 锁阻塞   lock
  - 无限等待  没有时间的等待
  - 计时等待  有指定时间的等待

### 同步解决线程安全问题  多线程操作一个共享资源,一定会有线程安全问题

锁的存在的意义

当我们使用多个线程去访问当一个资源的,如果多个线程对资源有读和写的操作,容易出现线程的安全问题

如果有固定的资源,使用时限Runnable接口的方式去卖票,票是固定的

1.  一个线程在操作的时候,其他线程必须要等待,直到操作完之后,其他线程才可以进来继续操作ticket,临界资源解决问题
2. 在Java中使用线程的同步机制  synchronized
   - 使用synchroinized 同步监听器,需要被同步的代码,为操作共享数据的代码
   - 共享数据,比如ticket
   - 一旦有人进去就会关上锁,出来之后就会打开锁,那个线程获取了锁,哪个线程就能够执行需要被同步的代码
   - 所有的线程都必须公用一个final值
   - 使用Runable的方式可以使用this来当做同步监听器,但是如果使用子类继承的话,则不可以
   - 同时可以使用**synchronized修饰符来进行修饰 实例方法**
3. 弊端 
   - 在操作共享数据的时候,多线程其实是串行执行,意味着性能低

### 线程安全的懒汉式

死锁机制

懒汉式存在安全问题,可以使用同步来进行解决

### Jdk5中Lock锁

### 线程的通信和基本举例

### jdk5.0新增创建两种多线程方式

